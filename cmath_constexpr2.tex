\documentclass[prd,preprint,amsmath,amssymb,nofootinbib,eqsecnum]{revtex4-1}

\usepackage{xspace} %Dude this will blow your mind!
\usepackage{amsthm}

\newcommand{\constexpr}{\code{constexpr}\xspace}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\header}[1]{{\tt <#1>}}
\newcommand{\cmath}{\header{cmath}}
\newcommand{\cstdlib}{\header{cstdlib}}

\newcommand{\FEINVALID}{{\tt FE\_INVALID}}
\newcommand{\FEDIVBYZERO}{{\tt FE\_DIVBYZERO}}
\newcommand{\FEINEXACT}{{\tt FE\_INEXACT}}
\newcommand{\FEUNDERFLOW}{{\tt FE\_UNDERFLOW}}
\newcommand{\FEOVERFLOW}{{\tt FE\_OVERFLOW}}
\newcommand{\Operators}{\ensuremath{+,-,\times,/}}

\newcommand{\highlight}[1]{{\bf #1}}

\newtheorem*{proposal*}{Proposal}

\begin{document}


\title{\constexpr for \cmath\ and \cstdlib}
\author{Edward J.~Rosten \& Oliver J.~Rosten}
\date{\today}

\begin{abstract}

We propose simple criteria for selecting functions in \cmath\ which should be
declared \constexpr. There is a small degree of overlap with \cstdlib.
 The essential aim is to transparently select a sufficiently large portion of \cmath\ 
in order to be useful but without placing too much burden on compiler vendors.
	
\end{abstract}


\maketitle

\tableofcontents

\section{Introduction}

This paper seeks to rectify the current absence of \constexpr in
\cmath\ (and also \cstdlib), so as to broaden the range of numeric computations that can be
performed using standard library facilities. While in principle almost every function
in \cmath\ could be declared \constexpr, we strike a balance between coverage and onus on compiler vendors.


\section{Motivation \& Scope}

The introduction of \constexpr has facilitated intuitive compile-time
programming. However, not a single function in \cmath\ is currently declared \constexpr which places
artificial restrictions on what can be done at compile-time within the standard library.
Nevertheless, from casual inspection of \cmath, it may
not be immediately obvious precisely which functions should be declared
\constexpr. In this paper, we seek an organizing principle which selects functions
which are in a sense no more complicated than the elementary arithmetic operations,
(\Operators). The is justified since the latter already support \constexpr.

To put the application of \constexpr on a rigorous footing, we
propose the following:
\begin{proposal*}
	A function in \cmath\ shall be declared \constexpr if:
	\begin{enumerate}
		\item When taken to act on the set of extended rational numbers, the function is closed;
		
		\item The function does not modify any if its arguments which have external visibility.
	\end{enumerate}
\end{proposal*}

It may seem that these criteria are insufficiently restrictive since various
functions satisfying both may, under certain conditions, set global flags.
Specifically, \code{errno} may be set and/or the various floating-point
exception flags, \FEDIVBYZERO, \FEINVALID, \FEOVERFLOW, \FEUNDERFLOW\ and
\FEINEXACT\ may be raised. The latter issue is 
faced by the standard
arithmetic operators but these are nevertheless available for use in constant
expressions. The proposed strategy is to mimic the behaviour of the arithmetic
operators.

To be precise, functions declared \constexpr, \emph{when used in a \constexpr
context}, should give a compiler error if division by zero, domain errors or
overflows occur. When not used in a \constexpr context, the various global
flags should be set as normal. This distinction between these two contexts
implies that any implementation cannot be done as a pure library extension.
Consequently, there will be some burden on compiler vendors. However, the first
criterion above ensures that the functions to be changed are in some sense
simple.

Both GCC and clang already support \constexpr within \cmath\ to varying extents. 
Indeed, GCC 5.3.0 declares all functions, with the exception of those taking a pointer argument
(cf.\ the second criterion), as \constexpr. Therefore, an implementation of the changes to the standard proposed in this paper is available (indeed, this implementation goes beyond what we propose).
While clang does not go nearly as far as GCC, it does offer some functions as 
builtins and is able to use them to perform compile time computations, constant
propagation and so on. It is therefore hoped that any burden on compiler vendors implicit in this
proposal is minimal.

\section{Impact On the Standard}

This proposal impacts the existing headers \cmath\ and \header{cstdlib} such
that the changes do not break existing code and do not degrade performance.
However, it is not a pure library extension. The subtlety arises because of the
requirement that some of the functions affected must behave differently
depending on whether or not they are used in a \constexpr context.

\section{Design Decisions}

There is at least one natural candidate in \header{cmath}, namely $\code{abs}$,
to which \constexpr should be applied, not least because this has already been proposed
for \code{complex::abs}~\cite{AP-complex}. But beyond this function, it is desirable to
apply \constexpr throughout \cmath\ in a consistent manner. For this purpose, ideally one would
like one or more criteria rooted in mathematics. However, the reality is that
this insufficiently restrictive. Nevertheless, mathematics was our starting
point; as such, any condition on functions to be \constexpr must select the
basic arithmetic operations, $+,-,\times,/$ since these are already \constexpr.

Mathematically, a field is closed under the elementary operations of addition
and multiplication.
Numeric types do not form a field; however, since the basic arithmetic
operations are already declared \constexpr, this suggests that it may be
possible to utilize a field which captures enough of the properties of numeric
types in order to be useful in formulating criteria for the application of
\constexpr. The rational numbers are the natural candidate since all valid
values of numeric types are elements of this set. The rationals close over
$+,-,\times,/$ (with zero excluded for division)
but functions such as \code{exp}, \code{sqrt}, \code{cos},
\code{sin} do not close and so are ruled out as \constexpr candidates
by our first criterion.

The subtlety of global flags being set upon encountering floating-point
exceptions presents a challenge. If all functions which can set such flags are
excluded from the list to tag \constexpr, then the remaining list is rather
sparse. To achieve something more useful suggests expanding the set to include
those functions which are `simple enough'. These considerations lead to the
first condition of the proposal.
Tables~\ref{tab:26.9.1}--\ref{tab:26.9.4} contain the functions in \cmath\
satisfying this criterion and indicate whether or not they pass the second
criterion as well. To reduce space, the following convention is observed. The
functions listed in section 26.9 are divided into blocks of closely related
functions such as those shown in \ref{tab:example}. 
\begin{table}
	\begin{tabular}{l}
		\code{int ilogb(float arg)}
	\\
		\code{int ilogb(double arg)}
	\\
		\code{int ilogb(long double arg)}
	\\
		\code{int ilogbf(float arg)}
	\\
		\code{int ilogbl(long double arg)}
	\end{tabular}
\caption{Example of a family of functions which appear as a block in the standard.}
\label{tab:example}
\end{table}
Note that while the first three functions are overloads, the fourth and fifth
have differing names.  When classifying those functions which satisfy the first
criterion, we will present just the first function in each such block, with the
understanding that the others are similar in this regard.

\begin{table}[h]
	\begin{tabular}{lcc}
		Function & Pass & Comment
	\\
	\hline \hline
		\code{float frexp(float value, int* exp)} & No & Modifies argument with external visibility
	\\
	\hline
		\code{int ilogb(float arg)} & Yes & May set global variable
	\\
	\hline
		\code{float logb(float arg)} & Yes & May set global variable
	\\
	\hline
		\code{float ldexp(float x, int exp)} & Yes & May set global variable
	\\
	\hline
		\code{float modf(float value, float* iptr)} & No & Modifies argument with external visibility
	\\
	\hline
		\code {float scalbn(float x, int n)} & Yes & May set global variable
	\\
	\hline
		\code {float scalbln(float x, long int n)} & Yes & May set global variable
	\end{tabular}
\caption{Functions declared in \S 26.9.1 which close on the rationals.}
\label{tab:26.9.1}
\end{table}


\begin{table}[h]
	\begin{tabular}{lc}
		Function & Pass
	\\
	\hline \hline
		\code{int abs(int j)} & Yes
	\\
	\hline
		\code{float fabs(float x)} & Yes
	\end{tabular}
\caption{Functions declared in \S 26.9.2 which close on the rationals.}
\label{tab:26.9.2}
\end{table}

\begin{table}[h]
	\begin{tabular}{lcc}
		Function & Pass & Comment
	\\
	\hline \hline
		\code{float ceil(float x)} &  Yes & Some implementations may set a global variable
	\\
	\hline
		\code{float floor(float x)} & Yes & Some implementations may set a global variable
	\\
	\hline
		\code{float nearbyint(float x)} & Yes &
	\\
	\hline
		\code{float rint(float x)} & Yes & May set a global variable
	\\
	\hline
		\code{long int lrint(float x)} &  Yes & May set a global variable
	\\
	\hline
		\code{long long int llrint(float x)} & Yes & May set a global variable 
	\\
	\hline
		\code{float round(float x)} & Yes & May set a global variable
	\\
	\hline
		\code{float lround(float x)} & Yes & May set a global variable
	\\
	\hline
		\code{float llround(float x)} & Yes & May set a global variable
	\\
	\hline
		\code{float trunc(float x)} &  Yes & May set a global variable
	\\
	\hline
		\code{float fmod(float x, float y)} & Yes & May set a global variable
	\\
	\hline
		\code{float remainder(float x, float y} & Yes & May set a global variable
	\\
	\hline
		\code{float remquo(float x, float y, int* quo)} & No & Modifies argument with external visibility
	\\
	\hline
		\code{float copysign(float x, float y)} & Yes &
	\\
	\hline
		\code{float nextafter(float x, float y)} & Yes & May set a global variable
	\\
	\hline
		\code{float nexttoward(float x, long double y)} & Yes & May set a global variable
	\\
	\hline
		\code{float fdim(float x, float y)} & Yes & May set a global variable
	\\
	\hline
		\code{float fmax(float x, float y)} & Yes &
	\\
	\hline
		\code{float fmin(float x, float y)} & Yes &
	\\
	\hline
		\code{float fma(float x, float y, float z)} & Yes & May set a global variable
	\end{tabular}
\caption{Functions declared in \S 26.9.3 which close on the rationals.}
\label{tab:26.9.3}
\end{table}

\begin{table}[h]
	\begin{tabular}{lcc}
		Function & Pass & Comment
	\\
	\hline \hline
		\code{int fpclassify(float x);} & Yes &
	\\
	\hline
		\code{int isfinite(float x)} & Yes &
	\\
	\hline
		\code{int isinf(float x)} & Yes & $\dagger$
	\\
	\hline
		\code{int isnan(float x)} & Yes & $\dagger$ 
	\\
	\hline
		\code{int isnormal(float x)} & Yes &
	\\
	\hline
		\code{int signbit(float x)} & Yes &
	\\
	\hline
		\code{int isgreater(float x, float y)} & Yes &
	\\
	\hline
		\code{int isgreaterequal(float x, float y)} & Yes &
	\\
	\hline
		\code{int isless(float x, float y)} & Yes &
	\\
	\hline
		\code{int islessequal(float x, float y)} & Yes &
	\\
	\hline
		\code{int islessgreater(float x, float y)} & Yes &
	\\
	\hline
		\code{int isunordered(float x, float y)} & Yes &
	\end{tabular}
\caption{Functions declared in \S 26.9.4 which close on the rationals. $\dagger$ --- no utility being declared \constexpr in of itself, but should be tagged \constexpr so that it can be incorporated into \constexpr functions since the latter may be called in  non-\constexpr contexts.}
\label{tab:26.9.4}
\end{table}


\section{Technical Specifications}

\subsection{Modifictions to ``Header \header{cstdlib} synopsis'' [cstdlib.syn]}

\code{namespace std\{

\ldots

\highlight{constexpr} int abs(int j);

\highlight{constexpr}  long int abs(long int j);

\highlight{constexpr}  long long int abs(long long int j);

\highlight{constexpr}  float abs(float j);

\highlight{constexpr} double abs(double j);

\highlight{constexpr} long double abs(long double j);

\vspace{2ex}

\highlight{constexpr} long int labs(long int j);

\highlight{constexpr}  long long int llabs(long long int j);

\vspace{2ex}

\highlight{constexpr} div\_t div(int numer, int denom);

\highlight{constexpr} ldiv\_t div(long int numer, long int denom); // see 17.2

\highlight{constexpr} lldiv\_t div(long long int numer, long long int denom); // see 17.2

\highlight{constexpr} ldiv\_t ldiv(long int numer, long int denom);

\highlight{constexpr} lldiv\_t lldiv(long long int numer, long long int denom);	

\}}

\subsection{Modifications to  ``Header \header{cmath} synopsis'' [cmath.syn]}

\code{

\ldots

namespace std\{

\ldots

float acos(float x); // see 17.2

double acos(double x);

long double acos(long double x); // see 17.2

float acosf(float x);

long double acosl(long double x);

\ldots

float frexp(float value, int* exp); // see 17.2

double frexp(double value, int* exp);

long double frexp(long double value, int* exp); // see 17.2

float frexpf(float value, int* exp);

long double frexpl(long double value, int* exp);

\vspace{2ex}

\highlight{constexpr} int ilogb(float x); // see 17.2

\highlight{constexpr} int ilogb(double x);

\highlight{constexpr} int ilogb(long double x); // see 17.2

\highlight{constexpr} int ilogbf(float x);

\highlight{constexpr} int ilogbl(long double x);

\vspace{2ex}

\highlight{constexpr} float ldexp(float x, int exp); // see 17.2

\highlight{constexpr} double ldexp(double x, int exp);

\highlight{constexpr} long double ldexp(long double x, int exp); // see 17.2

\highlight{constexpr} float ldexpf(float x, int exp);

\highlight{constexpr} long double ldexpl(long double x, int exp);

float log(float x); // see 17.2

double log(double x);

long double log(long double x); // see 17.2

float logf(float x);

long double logl(long double x);

\vspace{2ex}

float log10(float x); // see 17.2

double log10(double x);

long double log10(long double x); // see 17.2

float log10f(float x);

long double log10l(long double x);

\vspace{2ex}

float log1p(float x); // see 17.2

double log1p(double x);

long double log1p(long double x); // see 17.2

float log1pf(float x);

long double log1pl(long double x);

\vspace{2ex}

float log2(float x); // see 17.2

double log2(double x);

long double log2(long double x); // see 17.2

float log2f(float x);

long double log2l(long double x);

\vspace{2ex}

\highlight{constexpr} float logb(float x); // see 17.2

\highlight{constexpr} double logb(double x);

\highlight{constexpr} long double logb(long double x); // see 17.2

\highlight{constexpr} float logbf(float x);

\highlight{constexpr} long double logbl(long double x);

\vspace{2ex}

float modf(float value, float* iptr); // see 17.2

double modf(double value, double* iptr);

long double modf(long double value, long double* iptr); // see 17.2

float modff(float value, float* iptr);

long double modfl(long double value, long double* iptr);

\vspace{2ex}

\highlight{constexpr} float scalbn(float x, int n); // see 17.2

\highlight{constexpr} double scalbn(double x, int n);

\highlight{constexpr} long double scalbn(long double x, int n); // see 17.2

\highlight{constexpr} float scalbnf(float x, int n);

\highlight{constexpr} long double scalbnl(long double x, int n);

\vspace{2ex}

\highlight{constexpr} float scalbln(float x, long int n); // see 17.2

\highlight{constexpr} double scalbln(double x, long int n);

\highlight{constexpr} long double scalbln(long double x, long int n); // see 17.2

\highlight{constexpr} float scalblnf(float x, long int n);

\highlight{constexpr} long double scalblnl(long double x, long int n);

\vspace{2ex}

float cbrt(float x); // see 17.2

double cbrt(double x);

long double cbrt(long double x); // see 17.2

float cbrtf(float x);

long double cbrtl(long double x);

}


\begin{thebibliography}{1}
	\bibitem{AP-complex} Antony Polukhin, Constexpr for std::complex
\end{thebibliography}

\end{document}
