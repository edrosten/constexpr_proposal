\documentclass[prd,twocolumn,amsmath,amssymb,nofootinbib,eqsecnum]{revtex4-1}
\it
\usepackage{xspace} %Dude this will blow your mind!
\usepackage{amsthm}
\usepackage{color}
\usepackage{soul}
\usepackage{fancyvrb}
\usepackage{epsfig}
\usepackage{hyperref}

\newcommand{\constexpr}{\code{constexpr}\xspace}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\header}[1]{{\tt <#1>}}
\newcommand{\cmath}{\header{cmath}}
\newcommand{\complex}{\header{complex}}
\newcommand{\cstdlib}{\header{cstdlib}}

\newcommand{\ie}{i.e.}

\newcommand{\FEINVALID}{{\tt FE\_INVALID}}
\newcommand{\FEDIVBYZERO}{{\tt FE\_DIVBYZERO}}
\newcommand{\FEINEXACT}{{\tt FE\_INEXACT}}
\newcommand{\FEUNDERFLOW}{{\tt FE\_UNDERFLOW}}
\newcommand{\FEOVERFLOW}{{\tt FE\_OVERFLOW}}
\newcommand{\FLTRADIX}{{\tt FLT\_RADIX}}
\newcommand{\Operators}{\ensuremath{+,-,\times,/}}

\newcommand{\highlight}[1]{\colorbox{green}{\!\!\!\! #1}}
\newcommand{\oldhighlight}[1]{\colorbox{blue}{\!\!\!\! #1}}
\newcommand{\stdcomment}[1]{{// {\it see} [#1]}}

\newcommand{\eq}[1]{(\ref{eq:#1})}
\newcommand{\fig}[1]{figure~\ref{fig:#1}}
\newcommand{\sect}[1]{section~\ref{sec:#1}}

\newcommand{\bigund}{{\Huge{\_}}}

\newtheorem*{proposal*}{Proposal}

\makeatletter
\def\l@subsection#1#2{}
\def\l@subsubsection#1#2{}
\makeatother

\def\bibsection{\section*{\refname}} 

\begin{document}


\title{More \constexpr for \cmath\ and \complex}
%\author{Edward J.~Rosten \& Oliver J.~Rosten}
%\date{\today}

\author{
\hspace{11.5em}
\begin{tabular}{ll}
	Document: & D1383R1
\\
	Date: & \today
\\
	Project: & Programming Language C++, Library Working Group
\\
	Audience: & SG6 $\rightarrow$ LEWG $\rightarrow$ LWG $\rightarrow$ CWG
\\
	Reply to: & Edward J.\ Rosten {(\tt erosten@snap.com)}
 / Oliver J.\ Rosten {(\tt oliver.rosten@gmail.com)}
\end{tabular}
}

\begin{abstract}

\begin{center} {\bf Abstract} \end{center}

In~\cite{Rosten-constexpr}, a scattering of $\constexpr$, principally throughout \cmath, was proposed, and accepted into C++23. This was subject to a constraint that the affected functions be limited to those which are, in a well-defined sense, no more complicated than the arithmetic operators \Operators. It is proposed to remove this restriction, thereby allowing a richer spectrum of mathematical functions to be used in a \constexpr\ context. To help justify this, techniques from elementary topology are
utilized, to rigorously define a framework into which existing practice fits reasonably well. Deviations are
quantifiable and can be used to compute a number representing the Quality of Implementation.
	
\end{abstract}


\maketitle
\tableofcontents

\section{Introduction}

Since its inception, \constexpr\ has become an invaluable ingredient in compile-time programming. Indeed, part of its appeal is that the sharp distinction between meta-programming and runtime programming has in many instances become blurred. The interest in \constexpr\ is reflected by the numerous papers proposing to increase the range of core language features and library functionality that may be used in a \constexpr\ context. As such, it is essential for the long-term uniformity of C++ that parts of the standard library are not left behind in this process.

This paper is the natural extension of~\cite{Rosten-constexpr} and seeks to significantly expand the number of functions in \cmath\ (and also \complex) which may be used in a \constexpr context. The potential utility of this from numerics is noteworthy. However, it is clear that there are new hurdles to overcome: floating-point is very subtle and different people may want implementations to prioritize different things~\cite{Timmons-Less}. In other words, there is a non-trivial design space. Crudely, should implementations of floating-point functions be fast, or should they be accurate?

In fact, the issues run much deeper than this: how is accuracy even meaningfully defined for functions accepting floating-point input? To get a flavour for the subtleties, consider \code{std::sin(1e100)}.%
\footnote{Thanks to Richard Smith for first bringing this example to our attention.}
Whilst it is of course true that there is an unambiguous result to $\sin 10^{100}$, we may well wonder how meaningful it is, since shifting the argument by a tiny amount---of relative size $10^{-100}$---can cause the output to change dramatically. Indeed, the granularity of floating-point numbers at the scale of $10^{100}$ is such that $\sin x$ sweeps across its entire range from [-1,+1] many times as we go from one floating-point input to the next available one. Therefore, in this context, the fuzziness of floating-point
numbers makes the question of accuracy non-trivial.

On the other hand, if multiplying a number exactly representable as a floating-point number by two produced something off by the last bit, this would be highly concerning! One of the components of this paper is to show how elementary topology can provide a framework to understand both of these
extremes without providing a prejudicial opinion on the design space. The purpose of doing so is two fold:
\begin{enumerate}
	\item The lack of standardization of the output of mathematical functions in C++ means that practice
	has grown organically and largely unconstrained. A danger of this is that discussions have no
	grounding within an underlying formalism which can make progress hard. By providing a rigorous
	conceptual framework, this paper seeks to provide such grounding but without attempting to
	artificially and retrospectively constrain existing practice.
	
	\item The framework allows for Quality of Implementation (QoI) to be quantified in a way which 
	doesn't simply label all
	existing implementations as `bad', as might be the case if one insisted on `accuracy' to the last
	bit. Of course, there is no unique measure of QoI but this paper
	suggests a family which may help inform discussions.
\end{enumerate}

There is one final introductory point to make.
Given our belief that declaring more functions within \cmath\ to be \constexpr\ is useful, we seek to adhere to one of the core principles of C++~\cite{DandE}:
\begin{quote}
	It is more important to allow a useful feature than to prevent every misuse.
\end{quote}

\section{Motivation \& Scope}
\label{sec:Motivation}

\subsection{Initial Motivation \& Concerns}

Prior to~\cite{Rosten-constexpr}, no effort had been made to allow for functions in \cmath\ to be declared \constexpr; this despite there being glaring instances, such as \code{std::abs}, for which this was arguably perverse. Indeed, between~\cite{AP-complex} and~\cite{Rosten-constexpr} being adopted, the situation was actually been better for \complex\ than for \cmath! The aim of~\cite{Rosten-constexpr} was to at least partially rectify the situation, while recognizing that attempting to completely resolve this issue in a single shot was too ambitious.

The broad strategy of~\cite{Rosten-constexpr} is to focus on those functions which are, in a well-defined sense, no more complicated than the arithmetic operators \Operators; the rationale for this being that the latter are already available in a \constexpr\ context.
As~\cite{Rosten-constexpr} proceeded through the standardisation process, LEWG expressed a desire 
to extend the scope to include a significant amount of what remains in \cmath, in particular common mathematical functions such as \code{std::exp}.%
\footnote{It seems too ambitious at this stage to include the mathematical special functions [sf.cmath] and so they are excluded from this proposal.}
However, later discussion---crystalized in~\cite{Timmons-Less}---revealed significant concerns. Our hope is that these concerns can be overcome; to aid meaningful discussion, this proposal devotes space to describing a framework
for rigorously conceptualizing the various issues.

There are several related concerns to the goal of this paper to declare more functions in \cmath\ to be \constexpr:
\begin{enumerate}
	\item Implementations of certain functions in \cmath\ do not produce results which are `correctly' rounded to the last bit.
	
	\item The output of certain functions in \cmath\ may differ depending on whether they are evaluated at runtime or translation time.
	
	\item The output of certain functions in \cmath\ may depend on the level of optimization; a corollary
	is that even with a given level of (non-trivial) optimization, the same function in \cmath\ may give 
	different answers, depending on the ambient \href{https://godbolt.org/z/js7rGvPbf}{code}.%
	\footnote{Thanks to Matthias Kretz for supplying this example.}
	
	\item The output of certain functions in \cmath\ may differ when the same binary is executed on
	different CPUs within the same architectural family.
\end{enumerate}

\subsection{A Conceptual Framework}

\subsubsection{The Main Idea}

The key shift in perspective proposed is to stop thinking of floating-point numbers as simply numbers, and to instead think of them as {\it labels}. In particular, consider the real numbers, $\mathbf{R}^1$. Next define a sequence of overlapping open sets which cover the entire real number line (excluding $\pm \infty$). The open sets are called charts and the union of these charts is an atlas. Each individual chart, $C_{x_n}$, holds within it a single floating-point number, $x_n$, which may be considered its label. The subscript $n$ is used for convenience to index the floating-point numbers. This is ordered such that the next floating-point number is $x_{n+1}$. Each number is assumed to be unique and so $\pm 0$ are taken to be the same. The closure of 
$C_{x_n}$ includes the numbers $x_{n-1}$ and $x_{n+1}$ (which may be $\pm \infty$). Thus, each chart goes up to be doesn't quite touch the numbers on either side. This is illustrated in \fig{R1}.

The picture is somewhat reminiscent of Interval Arithmetic~\cite{Interval}, but with some key differences.
First, as will be described, the goal is not to quantify rounding errors, as such. Rather, the goal is to provide a set of \emph{equally valid} answers to a floating-point computations in a sense which will be made precise. Secondly, rather than the closed intervals of Interval Arithmetic, we employ overlapping open sets in a way which will be familiar from elementary topology.

\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{NumberLine.pdf_t}}
\caption{An atlas for the real numbers, with charts labelled by the floating-point numbers. Note how the gap between floating-point numbers increases, as the exponent increments.}
\label{fig:R1}
\end{center}
\end{figure}

The next step is to consider a function of a single floating-point argument, $f$, \ie\ a function which maps $\mathbf{R}^1$ into itself. This procedure can be straightforwardly extended to functions of $d$ arguments, which map $\mathbf{R}^d$ into $\mathbf{R}^1$. If the function is analytic within $C_{x_n}$, then this open set will be mapped into some other open set of $\mathbf{R}^1$, denoted $D^{f(x_n)}$. By construction, the intersection of $D^{f(x_n)}$ with the charts, $C$, is non-empty. Indeed, $D^{f(x_n)}$ intersects at least one chart, and in the case there are several they must have consecutive labels. In this manner, we can instead think of the function as mapping one label, $x_n$, into a set of labels $\{x_{m}, \ldots\}$, where the set is non-empty, and the elements are consecutive. This is illustrated in \fig{Function}.

\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{Functions.pdf_t}}
\caption{A function, analytic on the open set $C_{x_n}$, which maps it into the open set $D^{f(x_n)}$. The latter intersects with $C_{x_m}, \ldots, C_{x_{m+3}}$. In terms of sets of labels, the function can be considered to map the element $x_n$ into the set $\{x_m, \ldots, x_{m+3}\}$.}
\label{fig:Function}
\end{center}
\end{figure}

How does all of this abstract machinery relate to floating-point functions on real hardware? Given a function, $f$, denote a floating-point realization of this function by $F_I$, where the subscript parametrizes the precise implementation, the optimization used, the compiler flags used (such as \code{-ffast-math}), the hardware and anything else of relevance, except for the rounding mode. With this
in mind, suppose that, as in \fig{Function}, $f$ maps $C_{x_n}$ into $D^{f(x_n)}$. A necessary
condition for the realization, $F_I$, to be faithful is that, for every rounding mode, $F_I(x_n)$ yields
a value from the set $\{x_{m_n}, \ldots\}$. Since this needs to be true for all $x_n$, the dependence of $m$ on $n$ has been explicitly indicated, whereas previously it was suppressed, for brevity.

Some examples may clarify this. First, consider taking a number which has an exact floating-point representation and multiplying it by two.
In this case, $\{x_{m}, \ldots\}$ comprises just a single entry and our prescription demands an exact calculation. Secondly, take the example of \code{sin(1e100)}. In this case, $\{x_{m}, \ldots\}$ comprises all charts labelled by every representable number within the range $-1 \leq y \leq 1$. Our prescription states that every one of these numbers is an equally valid output from a faithful realization. This puts our earlier intuition on a firm footing.

Note that a necessary condition for a faithful realization has been given, but it is not claimed to
be sufficient. To understand why, observe in \fig{R1} that $C_{x_n}$ is perhaps twice a large as one
might expect. Indeed, if $\mathbf{R}^1$ were to be divided into disjoint intervals, these intervals would typically be half the size. The origin of this is that $C_{x_n}$ holds all of the values that could collapse to $x_n$ when considering all rounding modes. But when a specific rounding mode is chosen, only part of this range will actually collapse to $C_{x_n}$, with other values collapsing to either $C_{x_{n+1}}$ or $C_{x_{n-1}}$. The sufficient condition for a realization to be faithful would need to take this into account, but this is not required for our purposes.

\subsubsection{Singularities}

There are two types of singularities to consider: those arising from arguments that are/are not exactly representable as a floating-point number. An example of the former is $\ln 0$. An example of the latter is $\tan \pi/2$, since $\pi/2$ cannot be exactly represented as a floating-point number. Both can be incorporated into our framework in a similar way. Any number on the real line will appear in either exactly one of the $C_{x_n}$ or in exactly two: it appears in one if the number is exactly representable as a floating-point number and two, otherwise. Regardless, the next step is to introduce new open sets by copying those charts in which a singular point of the function, $f$, occurs and deleting said point. Each open set for which this is done spawns a pair of open sets in which the function is now analytic. Under the action of $f$, these open sets are now mapped into open sets. To complete the construction, the partial closure of these mapped sets is considered by reinstating the singular point. This is illustrated in \fig{Singularity}, which nicely illustrates how the procedure captures the fact that $\tan \pi/2$ can be either $\pm \infty$, depending on the direction from which the singularity is approached.
\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{Singularity.pdf_t}}
\caption{Excising a singular point from two charts which include $\pi/2$. The curved lines show how the nascent open sets are mapped into $\mathbf{R}^1$ under the action of $\tan$. The new charts to the left of $\pi/2$ are mapped to large positive numbers. Reinstating $\pi/2$ would provide the upper closure of these sets by $+\infty$. Similar considerations apply to the charts to the right of $\pi/2$, though here the mapping is in the vicinity of $-\infty$.}
\label{fig:Singularity}
\end{center}
\end{figure}

The rest of the prescription described above now follows, almost exactly as before. The only difference is that the $D^{(f_{x_n})}$ may now contain two disjoint, but individually consecutive, sequences.

\subsubsection{QoI}

There are many ways to define QoI. Here, the focus is on a definition which utilizes the necessary condition for a floating-point realization of a function to be faithful. As above, suppose that $f$
maps $C_{x_n}$ into $D^{f(x_n)}$ and that a faithful realization, $F_I(x_n)$, always yields one of the values in the set $\{x_{m_n}, \ldots\}$, whatever the rounding mode. The game now is to check,
for each $x_n$, whether this is true. The test fails if this violated for one of more rounding modes.
The percentage of passing tests is a measure of the QoI, $\mathcal{Q}$.

Compared to a refined scheme which does not aggregate the affects of the rounding mode, $\mathcal{Q}$
can be considered an upper bound in the QoI.


\subsection{Implications}

What does all of this mean in practice, especially when it comes to extending the reach of \constexpr\ throughout \cmath? The goal is not to be overly prescriptive, but rather to find a way of coherently and rigorously providing a framework  within which much of existing C++ practice and proposed extensions can reside. As such, we do not demand that the results of mathematical functions are necessarily the same at translation time and runtime. Indeed, we know that this can't be guaranteed and that differences have long occurred in practice. 

It is conceivable that this proposal may be abused, causing different platforms to generate radically
different code. For example, it will be possible to do things like this:
\begin{verbatim}
template<double D>
struct do_stuff
{
  static void execute() {}
};

template<>
struct do_stuff<1.0>
{
  static void execute() { destroy_everything(); }
};

// Do I feel lucky?
do_stuff<std::sin(1e100)>::execute();
\end{verbatim}

However, we believe that the utility of rolling out \constexpr\ to touch more of \cmath\ outweighs the fact that it may be misused, bringing us back to the core principle cited in the introduction, from~\cite{DandE}.
As for whether certain results may come as a surprise to users, again this is true. But that
is true of floating-point, period. It is a difficult, subtle area of programming fraught with difficulty
due to its frequently counter-intuitive nature.

One way or another, all of this boils down to the question of whether it is really acceptable for mathematical functions to give different results in different contexts, given the same input. Again, our answer is yes and we emphasise again that this is already part of C++. The above framework hopefully makes it clear that floating-point numbers are inherently fuzzy and that it is, in many cases, useful to embrace this fuzziness. That being said, there are cases where people may want a mathematical function to produce the same result, given the same input, in all situations (except, presumably, when the rounding mode is changed). Our opinion is that this is best served by a separate proposal, which
perhaps introduces new types. It is worth pointing out that Java gives a good idea of what this
may look like.


\section{State of the Art and Impact on Implementers}

\subsection{Current Implementations}

With the exception of the special functions [sf.cmath], functions taking a pointer argument and those with an explicit dependence on the runtime rounding mode, GCC currently renders almost everything in \cmath\ \constexpr. Though clang does not have \constexpr implementations, it does perform compile time evaluation of many mathematical functions (but not the special functions) during optimization. The existence of compile time evaluation in GCC and clang demonstrates that implementation of this proposal is plausibly feasible. 

Nevertheless, even for GCC's implementation of the relatively simple functions which~\cite{Rosten-constexpr} declares \constexpr, there are subtleties. In particular GCC is not entirely consistent with the way in which it presently deals with NaNs and/or infinities when they are passed as arguments to various mathematical functions.


\subsection{Special Values}

Two problems that~\cite{Rosten-constexpr} had to deal with was situations in which
\begin{enumerate}

\item Floating-point exceptions (other than \FEINEXACT) are raised;

\item NaNs and/or infinities are passed as arguments to functions in \cmath\ declared \constexpr.

\end{enumerate}
The chosen solution was to delegate to Annex F of the C standard insofar as it applicable.
Recall that Annex F specifies C language support for IEC 60559 arithmetic; thus, to the extent that a
floating-point type conforms to this, the behaviour in the aforementioned situations is 
exactly prescribed in C++, following the adoption of~\cite{Rosten-constexpr}. Should a
floating-point type not conform to relevant parts of IEC 60559, then its behaviour in these
situations is unspecified.

This strategy is applicable in its current form to this paper, though the range of scenarios
in which Annex F may be invoked is somewhat richer. For example, an implementation
conforming to IEC 60559 must give \code{acos(1) = +0}.

\subsection{Interaction with the C Standard Library}

For a mathematical function which may be evaluated at translation time, 
putting all peculiarities of floating-point momentarily to one side, it is desirable for there to be
consistency with the values computed at runtime. However, the fact that the rounding mode
may be changed at runtime indicates that this is not, in general, possible. 

However, for more complicated mathematical functions there is an additional subtlety due
to the interaction with the C standard library. In [library.c] it is noted that \cmath\ makes available the facilities of the C standard library. One interpretation of this is that the C++
implementation could use one of several different C standard libraries. If so, 
constraining translation time behaviour so that it is consistent with the runtime behaviour
could be very difficult, quite apart from the issue of the runtime rounding mode.

Let us return to an earlier example:
\begin{Verbatim}
#include <cmath>
double f() { return std::sin(1e100); }
\end{Verbatim}
It turns out that on clang (targeting x64), the following code is emitted:
\begin{Verbatim}
.LCPI0_0:
	.quad	-4622843457162800295 
_Z1fv:
	movsd	.LCPI0_0(%rip), %xmm0
	retq
\end{Verbatim}
with equivalent code generated by GCC. This demonstrates that both compilers are already generating the results at translation time and, therefore, independently of the runtime C library. For this particular example, it appears that current practise does indeed achieve consistency between translation time and runtime, though effectively by ignoring the latter!

The story does not end here. For more complicated examples and/or removing optimization, it may be that a runtime call to the C library is made, after all. Bearing in mind that any value in the range [-1, 1] could be considered reasonable, this implies that the value of, say, \code{std::sin(1e100)} evaluated in one part of a code base may be very different from the (translation time) value evaluated elsewhere. 
Nevertheless, it seems reasonable in our opinion that both clang and GCC tacitly allow this, as discussed in detail in \sect{Motivation} and further, below.

\subsection{QoI}

{\bf TO DO: numerical experiments with the major library implementations}


\section{Design Decisions}

The key design decision advocated in this paper is that it is acceptable for evaluation of a mathematical function to differ between translation time and runtime. Let us recapitulate the various points.

\begin{enumerate}
	\item Allowing a broader range of mathematical functions to be used within constant expressions is useful.
	
	\item Since the advent of \constexpr, the standard has implicitly allowed for differences between translation time and runtime evaluation: the arithmetic operators \Operators\ may be used in either context, but only in a runtime context may the rounding mode be changed.
	
	\item Even without \constexpr, current practice has long allowed for difference in the output of mathematical functions between any of translation time, runtime, runtime with different compiler flags, and runtime on a different platform. For example, optimization may emit code which entirely bypasses runtime calls to the C library, instead generating results at translation time. However, under other circumstances, optimization might not do this.
	
	\item The philosophy of this paper is not to accept an impasse. Rather, it is preferred to describe a rigorous framework which can be used to understand existing practice in a non-prejudicial fashion and allow for extensions in the same spirit.
\end{enumerate}


\section{Impact On the Standard}

This proposal amounts to a (further) liberal sprinkling of \constexpr\ in \cmath, together with a smattering in \complex.

\section{Future Directions}

Ultimately it would be desirable to extend \constexpr\ to some, if not all, of the special functions. Orthogonal to this, it may also be worth considering new types with strict guarantees on the values given by associated mathematical functions.


\begin{acknowledgments}
	We would like to thank Richard Smith for his usual perceptive comments and Matthias Kretz
	for some very helpful feedback.
\end{acknowledgments}


\begin{thebibliography}{1}
	\bibitem[P0533]{Rosten-constexpr} Edward J.~Rosten and Oliver J.~Rosten, \constexpr\ for \cmath\ and \cstdlib.

	\bibitem[P2337]{Timmons-Less} Nicholas G. Timmons, Less \constexpr\ for \cmath.
	
	\bibitem[D\&E]{DandE} Bjarne Stroustrup, The Design and Evolution of C++.

	\bibitem[P0415R0]{AP-complex} Antony Polukhin, Constexpr for std::complex.	
		
	\bibitem[N4901]{WorkingPaper} Thomas K\"oppe, ed., Working Draft, Standard for Programming Language C++.	
	
	\bibitem[Kahan]{Interval} William Kahan. 2006. How Futile Are Mindless Assessments of Roundoff in Floating-Point Computation? Retrieved \today\ from \url{https://people.eecs.berkeley.edu/?wkahan/Mindless.pdf}.
	
	%\bibitem[Rudin 1976]{BabyRudin} Walter Rudin, Principles of Mathematical Analysis, 3rd Edition.
\end{thebibliography}

\newpage

%\begin{widetext}
\onecolumngrid

\section{Proposed Wording}

\setlength{\parindent}{0pt}


The following proposed changes refer to the Working Paper~\cite{WorkingPaper}. Highlighting in \highlight{green} indicates changes proposed in this paper, whilst \oldhighlight{blue} indicates changes proposed in the companion paper, \cite{Rosten-constexpr}.



\subsection{Modifications to ``Header \header{complex} synposis'' [complex.syn]}

// [complex.value.ops], {\it values }

\vspace{2ex}

\code{
  	template<class T> constexpr T real(const complex<T>\&);
	
  	template<class T> constexpr T imag(const complex<T>\&);

	\vspace{2ex}

	template<class T> \highlight{constexpr} T abs(const complex<T>\&);
 	
	template<class T> \highlight{constexpr} T arg(const complex<T>\&);
	
	template<class T> constexpr T norm(const complex<T>\&);
	
	\vspace{2ex}
	
	template<class T> constexpr conj(const complex<T>\&);
	
	template<class T> \highlight{constexpr} proj(const complex<T>\&);
	
	template<class T> \highlight{constexpr} polar(const T\&, const T\& = T());	

}

\vspace{2ex}

// [complex.transcendentals], {\it transcendentals}

\code{

\vspace{2ex}
  template<class T> \highlight{constexpr} complex<T> acos(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> asin(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> atan(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> acosh(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> asinh(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> atanh(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> cos  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> cosh (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> exp  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> log  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> log10(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> pow  (const complex<T>\&, const T\&);

  template<class T> \highlight{constexpr} complex<T> pow  (const complex<T>\&, const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> pow  (const T\&, const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> sin  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> sinh (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> sqrt (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> tan  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> tanh (const complex<T>\&);
}

\subsection{Modifications to  ``Header \header{cmath} synopsis'' [cmath.syn]}


\code{

namespace std\{

\vspace{2ex}
\ldots
\vspace{2ex}

%% acos %%

\highlight{constexpr} float acos(float x); \stdcomment{library.c}

\highlight{constexpr} double acos(double x);

\highlight{constexpr} long double acos(long double x); \stdcomment{library.c}

\highlight{constexpr} float acosf(float x);

\highlight{constexpr} long double acosl(long double x);

\vspace{2ex}

%% asin %%

\highlight{constexpr} float asin(float x); \stdcomment{library.c}

\highlight{constexpr} double asin(double x);

\highlight{constexpr} long double asin(long double x); \stdcomment{library.c}

\highlight{constexpr} float asinf(float x);

\highlight{constexpr} long double asinl(long double x);

\vspace{2ex}

%% atan %%

\highlight{constexpr} float atan(float x); \stdcomment{library.c}

\highlight{constexpr} double atan(double x);

\highlight{constexpr} long double atan(long double x); \stdcomment{library.c}

\highlight{constexpr} float atanf(float x);

\highlight{constexpr} long double atanl(long double x);

\vspace{2ex}

%% atan2 %%

\highlight{constexpr} float atan2(float y, float x); \stdcomment{library.c}

\highlight{constexpr} double atan2(double y, double x);

\highlight{constexpr} long double atan2(long double y, long double x); \stdcomment{library.c}

\highlight{constexpr} float atan2f(float y, float x);

\highlight{constexpr} long double atan2l(long double y, long double x);

\vspace{2ex}

%% cos %%

\highlight{constexpr} float cos(float x); \stdcomment{library.c}

\highlight{constexpr} double cos(double x);

\highlight{constexpr} long double cos(long double x); \stdcomment{library.c}

\highlight{constexpr} float cosf(float x);

\highlight{constexpr} long double cosl(long double x);

\vspace{2ex}

%% sin %%

\highlight{constexpr} float sin(float x); \stdcomment{library.c}

\highlight{constexpr} double sin(double x);

\highlight{constexpr} long double sin(long double x); \stdcomment{library.c}

\highlight{constexpr} float sinf(float x);

\highlight{constexpr} long double sinl(long double x);

\vspace{2ex}

%% tan %%

\highlight{constexpr} float tan(float x); \stdcomment{library.c}

\highlight{constexpr} double tan(double x);

\highlight{constexpr} long double tan(long double x); \stdcomment{library.c}

\highlight{constexpr} float tanf(float x);

\highlight{constexpr} long double tanl(long double x);

\vspace{2ex}

%% acosh %%

\highlight{constexpr} float acosh(float x); \stdcomment{library.c}

\highlight{constexpr} double acosh(double x);

\highlight{constexpr} long double acosh(long double x); \stdcomment{library.c}

\highlight{constexpr} float acoshf(float x);

\highlight{constexpr} long double acoshl(long double x);

\vspace{2ex}

%% asinh %%

\highlight{constexpr} float asinh(float x); \stdcomment{library.c}

\highlight{constexpr} double asinh(double x);

\highlight{constexpr} long double asinh(long double x); \stdcomment{library.c}

\highlight{constexpr} float asinhf(float x);

\highlight{constexpr} long double asinhl(long double x);

\vspace{2ex}

%% atanh %%

\highlight{constexpr} float atanh(float x); \stdcomment{library.c}

\highlight{constexpr} double atanh(double x);

\highlight{constexpr} long double atanh(long double x); \stdcomment{library.c}

\highlight{constexpr} float atanhf(float x);

\highlight{constexpr} long double atanhl(long double x);

\vspace{2ex}

%% cosh %%

\highlight{constexpr} float cosh(float x); \stdcomment{library.c}

\highlight{constexpr} double cosh(double x);

\highlight{constexpr} long double cosh(long double x); \stdcomment{library.c}

\highlight{constexpr} float coshf(float x);

\highlight{constexpr} long double coshl(long double x);

\vspace{2ex}

%% sinh %%

\highlight{constexpr} float sinh(float x); \stdcomment{library.c}

\highlight{constexpr} double sinh(double x);

\highlight{constexpr} long double sinh(long double x); \stdcomment{library.c}

\highlight{constexpr} float sinhf(float x);

\highlight{constexpr} long double sinhl(long double x);

\vspace{2ex}

%% tanh %%

\highlight{constexpr} float tanh(float x); \stdcomment{library.c}

\highlight{constexpr} double tanh(double x);

\highlight{constexpr} long double tanh(long double x); \stdcomment{library.c}

\highlight{constexpr} float tanhf(float x);

\highlight{constexpr} long double tanhl(long double x);

\vspace{2ex}

%% exp %%

\highlight{constexpr} float exp(float x); \stdcomment{library.c}

\highlight{constexpr} double exp(double x);

\highlight{constexpr} long double exp(long double x); \stdcomment{library.c}

\highlight{constexpr} float expf(float x);

\highlight{constexpr} long double expl(long double x);

\vspace{2ex}

%% exp2 %%

\highlight{constexpr} float exp2(float x); \stdcomment{library.c}

\highlight{constexpr} double exp2(double x);

\highlight{constexpr} long double exp2(long double x); \stdcomment{library.c}

\highlight{constexpr} float exp2f(float x);

\highlight{constexpr} long double exp2l(long double x);

\vspace{2ex}

%% expm1 %%

\highlight{constexpr} float expm1(float x); \stdcomment{library.c}

\highlight{constexpr} double expm1(double x);

\highlight{constexpr} long double expm1(long double x); \stdcomment{library.c}

\highlight{constexpr} float expm1f(float x);

\highlight{constexpr} long double expm1l(long double x);

\vspace{2ex}

%% frexp %%

\oldhighlight{constexpr}  float frexp(float value, int* exp); \stdcomment{library.c}

\oldhighlight{constexpr}  double frexp(double value, int* exp);

\oldhighlight{constexpr}  long double frexp(long double value, int* exp); \stdcomment{library.c}

\oldhighlight{constexpr}  float frexpf(float value, int* exp);

\oldhighlight{constexpr}  long double frexpl(long double value, int* exp);

\vspace{2ex}

%% ilogb %%

\oldhighlight{constexpr} int ilogb(float x); \stdcomment{library.c}

\oldhighlight{constexpr} int ilogb(double x);

\oldhighlight{constexpr} int ilogb(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} int ilogbf(float x);

\oldhighlight{constexpr} int ilogbl(long double x);

\vspace{2ex}

%% ldexp %%

\oldhighlight{constexpr} float ldexp(float x, int exp); \stdcomment{library.c}

\oldhighlight{constexpr} double ldexp(double x, int exp);

\oldhighlight{constexpr} long double ldexp(long double x, int exp); \stdcomment{library.c}

\oldhighlight{constexpr} float ldexpf(float x, int exp);

\oldhighlight{constexpr} long double ldexpl(long double x, int exp);

\vspace{2ex}

%% log %%

\highlight{constexpr} float log(float x); \stdcomment{library.c}

\highlight{constexpr} double log(double x);

\highlight{constexpr} long double log(long double x); \stdcomment{library.c}

\highlight{constexpr} float logf(float x);

\highlight{constexpr} long double logl(long double x);

\vspace{2ex}

%% log 10 %%

\highlight{constexpr} float log10(float x); \stdcomment{library.c}

\highlight{constexpr} double log10(double x);

\highlight{constexpr} long double log10(long double x); \stdcomment{library.c}

\highlight{constexpr} float log10f(float x);

\highlight{constexpr} long double log10l(long double x);

\vspace{2ex}

%% loglp %%

\highlight{constexpr} float log1p(float x); \stdcomment{library.c}

\highlight{constexpr} double log1p(double x);

\highlight{constexpr}long double log1p(long double x); \stdcomment{library.c}

\highlight{constexpr} float log1pf(float x);

\highlight{constexpr} long double log1pl(long double x);

\vspace{2ex}

%% log2 %%

\highlight{constexpr} float log2(float x); \stdcomment{library.c}

\highlight{constexpr} double log2(double x);

\highlight{constexpr} long double log2(long double x); \stdcomment{library.c}

\highlight{constexpr} float log2f(float x);

\highlight{constexpr} long double log2l(long double x);

\vspace{2ex}

%% logb %%

\oldhighlight{constexpr} float logb(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double logb(double x);

\oldhighlight{constexpr} long double logb(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float logbf(float x);

\oldhighlight{constexpr} long double logbl(long double x);

\vspace{2ex}

%% modf %%

\oldhighlight{constexpr}  float modf(float value, float* iptr); \stdcomment{library.c}

\oldhighlight{constexpr}  double modf(double value, double* iptr);

\oldhighlight{constexpr}  long double modf(long double value, long double* iptr); \stdcomment{library.c}

\oldhighlight{constexpr}  float modff(float value, float* iptr);

\oldhighlight{constexpr}  long double modfl(long double value, long double* iptr);

\vspace{2ex}

%% scalbn %%

\oldhighlight{constexpr} float scalbn(float x, int n); \stdcomment{library.c}

\oldhighlight{constexpr} double scalbn(double x, int n);

\oldhighlight{constexpr} long double scalbn(long double x, int n); \stdcomment{library.c}

\oldhighlight{constexpr} float scalbnf(float x, int n);

\oldhighlight{constexpr} long double scalbnl(long double x, int n);

\vspace{2ex}

%% scalbln %%

\oldhighlight{constexpr} float scalbln(float x, long int n); \stdcomment{library.c}

\oldhighlight{constexpr} double scalbln(double x, long int n);

\oldhighlight{constexpr} long double scalbln(long double x, long int n); \stdcomment{library.c}

\oldhighlight{constexpr} float scalblnf(float x, long int n);

\oldhighlight{constexpr} long double scalblnl(long double x, long int n);

\vspace{2ex}

\highlight{constexpr} float cbrt(float x); \stdcomment{library.c}

\highlight{constexpr} double cbrt(double x);

\highlight{constexpr} long double cbrt(long double x); \stdcomment{library.c}

\highlight{constexpr} float cbrtf(float x);

\highlight{constexpr} long double cbrtl(long double x);

\vspace{2ex}

//  [c.math.abs], {\it absolute values}

%% abs %%

\oldhighlight{constexpr} int abs(int j);

\oldhighlight{constexpr} long int abs(long int j);

\oldhighlight{constexpr} long long int abs(long long int j);

\oldhighlight{constexpr} float abs(float j);

\oldhighlight{constexpr} double abs(double j);

\oldhighlight{constexpr}long double abs(long double j);

\vspace{2ex}

%% fabs %%

\oldhighlight{constexpr} float fabs(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double fabs(double x);

\oldhighlight{constexpr} long double fabs(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float fabsf(float x);

\oldhighlight{constexpr} long double fabsl(long double x);

\vspace{2ex}

%% hypot %%

\highlight{constexpr} float hypot(float x, float y); \stdcomment{library.c}

\highlight{constexpr} double hypot(double x, double y);

\highlight{constexpr} long double hypot(long double x, long double y); \stdcomment{library.c}

\highlight{constexpr} float hypotf(float x, float y);

\highlight{constexpr} long double hypotl(long double x, long double y);

\vspace{2ex}

// [c.math.hypot3], {\it three-dimensional hypotenuse}

%% hypot3 5%

\highlight{constexpr} float hypot(float x, float y, float z);

\highlight{constexpr} double hypot(double x, double y, double z);

\highlight{constexpr} long double hypot(long double x, long double y, long double z);

%% pow %%
\vspace{2ex}

\highlight{constexpr} float pow(float x, float y); \stdcomment{library.c}

\highlight{constexpr} double pow(double x, double y);

\highlight{constexpr} long double pow(double x, double y); \stdcomment{library.c}

\highlight{constexpr} float powf(float x, float y);

\highlight{constexpr} long double powl(long double x, long double y);

\vspace{2ex}

%% sqrt %%

\highlight{constexpr} float sqrt(float x); \stdcomment{library.c}

\highlight{constexpr} double sqrt(double x);

\highlight{constexpr} long double sqrt(double x); \stdcomment{library.c}

\highlight{constexpr} float sqrtf(float x);

\highlight{constexpr} long double sqrtl(long double x);

\vspace{2ex}

%% erf %%

\highlight{constexpr} float erf(float x); \stdcomment{library.c}

\highlight{constexpr} double erf(double x);

\highlight{constexpr} long double erf(long double x); \stdcomment{library.c}

\highlight{constexpr} float erff(float x);

\highlight{constexpr} long double erfl(long double x);

\vspace{2ex}
%% erfc %%

\highlight{constexpr} float erfc(float x); \stdcomment{library.c}

\highlight{constexpr} double erfc(double x);

\highlight{constexpr} long double erfc(long double x); \stdcomment{library.c}

\highlight{constexpr} float erfcf(float x);

\highlight{constexpr} long double erfcl(long double x);

\vspace{2ex}

%% lgamma %%

\highlight{constexpr} float lgamma(float x); \stdcomment{library.c}

\highlight{constexpr} double lgamma(double x);

\highlight{constexpr} long double lgamma(long double x); \stdcomment{library.c}

\highlight{constexpr} float lgammaf(float x);

\highlight{constexpr} long double lgammal(long double x);

\vspace{2ex}
%% tgamma %%

\highlight{constexpr} float tgamma(float x); \stdcomment{library.c}

\highlight{constexpr} double tgamma(double x);

\highlight{constexpr} long double tgamma(long double x); \stdcomment{library.c}

\highlight{constexpr} float tgammaf(float x);

\highlight{constexpr} long double tgammal(long double x);

\vspace{2ex}
%% ceil %%

\oldhighlight{constexpr} float ceil(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double ceil(double x);

\oldhighlight{constexpr} long double ceil(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float ceilf(float x);

\oldhighlight{constexpr} long double ceill(long double x);

\vspace{2ex}

%% floor %%

\oldhighlight{constexpr} float floor(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double floor(double x);

\oldhighlight{constexpr} long double floor(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float floorf(float x);

\oldhighlight{constexpr} long double floorl(long double x);

\vspace{2ex}

%% nearbyint %%

float nearbyint(float x); \stdcomment{library.c}

double nearbyint(double x);

long double nearbyint(long double x); \stdcomment{library.c}

 float nearbyintf(float x);

 long double nearbyintl(long double x);

\vspace{2ex}

%% rint %%

 float rint(float x); \stdcomment{library.c}

 double rint(double x);

long double rint(long double x); \stdcomment{library.c}

 float rintf(float x);

 long double rintl(long double x);

\vspace{2ex}

%% lrint %%

long int lrint(float x); \stdcomment{library.c}

 long int lrint(double x);

long int lrint(long double x); \stdcomment{library.c}

 long int lrintf(float x);

long int lrintl(long double x);

\vspace{2ex}

%% llrint %%

long long int llrint(float x); \stdcomment{library.c}

long long int llrint(double x);

long long int llrint(long double x); \stdcomment{library.c}

long long int llrintf(float x);

long long int llrintl(long double x);

\vspace{2ex}

%% round %%

\oldhighlight{constexpr} float round(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double round(double x);

\oldhighlight{constexpr} long double round(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float roundf(float x);

\oldhighlight{constexpr} long double roundl(long double x);

\vspace{2ex}

%% lround %%

\oldhighlight{constexpr} long int lround(float x); \stdcomment{library.c}

\oldhighlight{constexpr} long int lround(double x);

\oldhighlight{constexpr} long int lround(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} long int lroundf(float x);

\oldhighlight{constexpr} long int lroundl(long double x);

\vspace{2ex}

%% llround %%

\oldhighlight{constexpr} long long int llround(float x); \stdcomment{library.c}

\oldhighlight{constexpr} long long int llround(double x);

\oldhighlight{constexpr} long long int llround(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} long long int llroundf(float x);

\oldhighlight{constexpr} long long int llroundl(long double x);

\vspace{2ex}

%% trunc %%

\oldhighlight{constexpr} float trunc(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double trunc(double x);

\oldhighlight{constexpr} long double trunc(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float truncf(float x);

\oldhighlight{constexpr} long double truncl(long double x);

\vspace{2ex}

%% fmod %%

\oldhighlight{constexpr} float fmod(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double fmod(double x, double y);

\oldhighlight{constexpr} long double fmod(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float fmodf(float x, float y);

\oldhighlight{constexpr} long double fmodl(long double x, long double y);

\vspace{2ex}

%% remainder %%

\oldhighlight{constexpr} float remainder(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double remainder(double x, double y);

\oldhighlight{constexpr} long double remainder(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float remainderf(float x, float y);

\oldhighlight{constexpr} long double remainderl(long double x, long double y);

\vspace{2ex}

%% remquo %%

\oldhighlight{constexpr}  float remquo(float x, float y, int* quo); \stdcomment{library.c}

\oldhighlight{constexpr}  double remquo(double x, double y, int* quo);

\oldhighlight{constexpr}  long double remquo(long double x, long double y, int* quo); \stdcomment{library.c}

\oldhighlight{constexpr}  float remquof(float x, float y, int* quo);

\oldhighlight{constexpr}  long double remquol(long double x, long double y, int* quo);

\vspace{2ex}

%% copysign %%

\oldhighlight{constexpr} float copysign(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double copysign(double x, double y);

\oldhighlight{constexpr} long double copysign(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float copysignf(float x, float y);

\oldhighlight{constexpr} long double copysignl(long double x, long double y);

\vspace{2ex}

double nan(const char* tagp);

float nanf(const char* tagp);

long double nanl(const char* tagp);

\vspace{2ex}

%% nextafter %%

\oldhighlight{constexpr}  float nextafter(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double nextafter(double x, double y);

\oldhighlight{constexpr}  long double nextafter(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float nextafterf(float x, float y);

\oldhighlight{constexpr}  long double nextafterl(long double x, long double y);

\vspace{2ex}

%% nexttoward %%

\oldhighlight{constexpr}  float nexttoward(float x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  double nexttoward(double x, long double y);

\oldhighlight{constexpr}  long double nexttoward(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float nexttowardf(float x, long double y);

\oldhighlight{constexpr}  long double nexttowardl(long double x, long double y);

\vspace{2ex}

%% fdim %%

\oldhighlight{constexpr}  float fdim(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fdim(double x, double y);

\oldhighlight{constexpr}  long double fdim(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fdimf(float x, float y);

\oldhighlight{constexpr}  long double fdiml(long double x, long double y);

\vspace{2ex}

%% fmax %%

\oldhighlight{constexpr}  float fmax(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fmax(double x, double y);

\oldhighlight{constexpr}  long double fmax(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fmaxf(float x, float y);

\oldhighlight{constexpr}  long double fmaxl(long double x, long double y);

\vspace{2ex}

%% fmin %%

\oldhighlight{constexpr} float fmin(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fmin(double x, double y);

\oldhighlight{constexpr}  long double fmin(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fminf(float x, float y);

\oldhighlight{constexpr} long double fminl(long double x, long double y);

\vspace{2ex}

%% fma %%

\oldhighlight{constexpr}  float fma(float x, float y, float z); \stdcomment{library.c}

\oldhighlight{constexpr}  double fma(double x, double y, double z);

\oldhighlight{constexpr}  long double fma(long double x, long double y, long double z); \stdcomment{library.c}

\oldhighlight{constexpr}  float fmaf(float x, float y, float z);

\oldhighlight{constexpr}  long double fmal(long double x, long double y, long double z);

\vspace{2ex}

// [c.math.fpclass], {\it classification / comparison functions:}

%% fpclassify %%

\oldhighlight{constexpr} int fpclassify(float x);

\oldhighlight{constexpr} int fpclassify(double x);

\oldhighlight{constexpr} int fpclassify(long double x);

\vspace{2ex}

%% isinfinite %%

\oldhighlight{constexpr} int isfinite(float x);

\oldhighlight{constexpr} int isfinite(double x);

\oldhighlight{constexpr} int isfinite(long double x);

\vspace{2ex}

%% isinf %%

\oldhighlight{constexpr} int isinf(float x);

\oldhighlight{constexpr} int isinf(double x);

\oldhighlight{constexpr} int isinf(long double x);

\vspace{2ex}

%% isnan %%

\oldhighlight{constexpr} int isnan(float x);

\oldhighlight{constexpr} int isnan(double x);

\oldhighlight{constexpr} int isnan(long double x);

\vspace{2ex}

%% isnormal %%

\oldhighlight{constexpr} int isnormal(float x);

\oldhighlight{constexpr} int isnormal(double x);

\oldhighlight{constexpr} int isnormal(long double x);

\vspace{2ex}

%% signbit %%

\oldhighlight{constexpr} int signbit(float x);

\oldhighlight{constexpr} int signbit(double x);

\oldhighlight{constexpr} int signbit(long double x);

\vspace{2ex}

%% isgreater %%

\oldhighlight{constexpr} int isgreater(float x, float y);

\oldhighlight{constexpr} int isgreater(double x, double y);

\oldhighlight{constexpr} int isgreater(long double x, long double y);

\vspace{2ex}

%% isgreaterequal %%

\oldhighlight{constexpr} int isgreaterequal(float x, float y);

\oldhighlight{constexpr} int isgreaterequal(double x, double y);

\oldhighlight{constexpr} int isgreaterequal(long double x, long double y);

\vspace{2ex}

%% isless %%

\oldhighlight{constexpr} int isless(float x, float y);

\oldhighlight{constexpr} int isless(double x, double y);

\oldhighlight{constexpr} int isless(long double x, long double y);

\vspace{2ex}

%% islessequal %%

\oldhighlight{constexpr} int islessequal(float x, float y);

\oldhighlight{constexpr} int islessequal(double x, double y);

\oldhighlight{constexpr} int islessequal(long double x, long double y);

\vspace{2ex}

%% islessgreater %%

\oldhighlight{constexpr} int islessgreater(float x, float y);

\oldhighlight{constexpr} int islessgreater(double x, double y);

\oldhighlight{constexpr} int islessgreater(long double x, long double y);

\vspace{2ex}

%% isunordered %%

\oldhighlight{constexpr} int isunordered(float x, float y);

\oldhighlight{constexpr} int isunordered(double x, double y);

\oldhighlight{constexpr} int isunordered(long double x, long double y);

}


\subsection{Modifications to ``Three-dimensional hypotenuse''  [c.math.hpot3]}

\code{
	\highlight{constexpr} float hypot(float x, float y); 

	\highlight{constexpr} double hypot(double x, double y);

	\highlight{constexpr} long double hypot(double x, double y); 
}

\end{document}
