\documentclass[prd,twocolumn,amsmath,amssymb,nofootinbib,eqsecnum]{revtex4-1}
\it
\usepackage{xspace} %Dude this will blow your mind!
\usepackage{amsthm}
\usepackage{color}
\usepackage{soul}
\usepackage{fancyvrb}
\usepackage{epsfig}

\newcommand{\constexpr}{\code{constexpr}\xspace}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\header}[1]{{\tt <#1>}}
\newcommand{\cmath}{\header{cmath}}
\newcommand{\complex}{\header{complex}}
\newcommand{\cstdlib}{\header{cstdlib}}

\newcommand{\ie}{i.e.}

\newcommand{\FEINVALID}{{\tt FE\_INVALID}}
\newcommand{\FEDIVBYZERO}{{\tt FE\_DIVBYZERO}}
\newcommand{\FEINEXACT}{{\tt FE\_INEXACT}}
\newcommand{\FEUNDERFLOW}{{\tt FE\_UNDERFLOW}}
\newcommand{\FEOVERFLOW}{{\tt FE\_OVERFLOW}}
\newcommand{\FLTRADIX}{{\tt FLT\_RADIX}}
\newcommand{\Operators}{\ensuremath{+,-,\times,/}}

\newcommand{\highlight}[1]{{\color{green} #1}}
\newcommand{\oldhighlight}[1]{{\color{blue} #1}}
\newcommand{\stdcomment}[1]{{// {\it see} [#1]}}

\newcommand{\eq}[1]{(\ref{eq:#1})}
\newcommand{\fig}[1]{figure~\ref{fig:#1}}

\newcommand{\bigund}{{\Huge{\_}}}

\newtheorem*{proposal*}{Proposal}

\makeatletter
\def\l@subsection#1#2{}
\def\l@subsubsection#1#2{}
\makeatother

\def\bibsection{\section*{\refname}} 

\begin{document}


\title{More \constexpr for \cmath\ and \complex}
%\author{Edward J.~Rosten \& Oliver J.~Rosten}
%\date{\today}

\author{
\hspace{11.5em}
\begin{tabular}{ll}
	Document: & D1383R1
\\
	Date: & \today
\\
	Project: & Programming Language C++, Library Working Group
\\
	Audience: & SG6 $\rightarrow$ LEWG $\rightarrow$ LWG $\rightarrow$ CWG
\\
	Reply to: & Edward J.\ Rosten {(\tt erosten@snap.com)}
 / Oliver J.\ Rosten {(\tt oliver.rosten@gmail.com)}
\end{tabular}
}

\begin{abstract}

\begin{center} {\bf Abstract} \end{center}

In~\cite{Rosten-constexpr}, a scattering of $\constexpr$, principally throughout \cmath, was proposed, and accepted into C++23. This was subject to a constraint that the affected functions be limited to those which are, in a well-defined sense, no more complicated than the arithmetic operators \Operators. We propose removing this restriction, thereby allowing a richer spectrum of mathematical functions to be used in a \constexpr\ context. To justify this, a mathematical framework is proposed in order to rigorously define, without being overly prescriptive, what it means for the implementation of a mathematical function accepting floating-point arguments to conform to the C++ standard.
	
\end{abstract}


\maketitle
\tableofcontents

\section{Introduction}

Since its inception, \constexpr\ has become an invaluable ingredient in compile-time programming. Indeed, part of its appeal is that the sharp distinction between meta-programming and runtime programming has in many instances become blurred. The interest in \constexpr\ is reflected by the numerous papers proposing to increase the range of core language features and library functions that may be used in a \constexpr\ context. As such, it is essential for the long-term uniformity of C++ that parts of the standard library are not left behind in this process.

This paper is the natural extension of~\cite{Rosten-constexpr} and seeks to significantly expand the number of functions in \cmath\ (and also \complex) which may be used in a \constexpr context. The potential utility of this from numerics is noteworthy. However, it is clear that there are new hurdles to overcome: floating-point is very subtle and different people may want implementations to prioritize different things~\cite{Timmons-Less}. In other words, there is a non-trivial design space. Crudely, should implementations of floating-point functions be fast, or should they be accurate? There is no definitive answer to this since it depends on the circumstance and interests of the particular user. One of the key components to this paper is to propose a mathematical framework sufficiently flexible to represent this design space, thereby making it amenable to standardization.

Given our belief that declaring more functions within \cmath\ to be \constexpr\ is useful, we seek to adhere to one of the core principles of C++~\cite{DandE}:
\begin{quote}
	It is more important to allow a useful feature than to prevent every misuse.
\end{quote}

\section{Motivation \& Scope}

\subsection{Initial Motivation \& Concerns}

Prior to~\cite{Rosten-constexpr}, no effort had been made to allow for functions in \cmath\ to be declared \constexpr; this despite there being glaring instances, such as \code{std::abs}, for which it was arguably perverse for them to have been unavailable for compile-time computation for as long as they were. Indeed, between~\cite{AP-complex} and~\cite{Rosten-constexpr} being adopted, the situation was actually been better for \complex\ than for \cmath! The aim of~\cite{Rosten-constexpr} was to at least partially rectify the situation, while recognizing that attempting to completely resolve this issue in a single shot was too ambitious.

The broad strategy of~\cite{Rosten-constexpr} is to focus on those functions which are, in a well-defined sense, no more complicated than the arithmetic operators \Operators; the rationale for this being that the latter are already available in a \constexpr\ context.
As~\cite{Rosten-constexpr} proceeded through the standardisation process, LEWG expressed a desire 
to extend the scope to include a significant amount of what remains in \cmath, in particular common mathematical functions such as \code{std::exp}. However, later discussion---crystalized in~\cite{Timmons-Less}---revealed significant concerns. Our hope is that these concerns can be overcome. Attempting to do so has broadened the scope of this proposal to include a new framework for conceptualizing floating-point computation.
Note, though, that in terms of scope it seems too ambitious at this stage to include the mathematical special functions [sf.cmath] and so they are excluded from this proposal.

There are two related concerns to the goal of this paper to declare more functions in \cmath\ to be \constexpr:
\begin{enumerate}
	\item Implementations of certain functions in \cmath\ do not produce results which are `correctly' rounded to the last bit.
	
	\item The output of certain functions in \cmath\ may differ depending on whether they are evaluated at runtime or translation time.
\end{enumerate}

\subsection{A Conceptual Framework}

\subsubsection{Preamble}

A crucial point to make, which motivates much of what follows, is that it is not straightforward to define what one means by correct rounding of a mathematical function, due to the peculiarities of floating-point numbers. Consider two examples at opposite extremes. On the one hand, if multiplying a number exactly representable as a floating-point number by two produced something off by the last bit, this would be highly concerning! On the other, what does it mean for something like \code{std::sin(1e100)} to be correctly rounded%
\footnote{Thanks to Richard Smith for first bringing this example to our attention}? Whilst it is of course true that there is an unambiguous result to $\sin 1\mathrm{e}100$, we may well wonder how meaningful it is, since shifting the argument by a tiny amount can cause the output to change dramatically. Indeed, the granularity of floating-point numbers at the scale of $1\mathrm{e}100$ is such that $\sin x$ sweeps across its entire range from [-1,+1] many times as we go from one floating-point input to the next available one. In this sense there is a fuzziness to floating-point numbers. We now put in place a framework to allow a rigorous treatment of these issues.

\subsubsection{The Main Idea}

The key shift in perspective that we propose is to stop thinking of floating-point numbers as simply numbers, and to instead consider them as {\it labels}. In particular, consider the real numbers, $\mathbf{R}^1$. Next define a sequence of overlapping open sets which cover the entire real number line (excluding $\pm \infty$). The open sets are called charts and the union of these charts is an atlas. Each individual chart, $C_{x_n}$, holds within it a single floating-point number, $x_n$, which may be considered its label. The subscript $n$ is used for convenience to index the floating-point numbers. This is ordered such that the next floating-point number is $x_{n+1}$. Each number is assumed to be unique and so $\pm 0$ are taken to be the same. The closure of 
$C_{x_n}$ includes the numbers $x_{n-1}$ and $x_{n+1}$ (which may be $\pm \infty$). Thus, each chart goes up to be doesn't quite touch the numbers on either side. This is illustrated in \fig{R1}

\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{NumberLine.pdf_t}}
\caption{An atlas for the real numbers, with charts labelled by the floating-point numbers. Note how the gap between floating-point numbers increases, as the exponent increments.}
\label{fig:R1}
\end{center}
\end{figure}

The next step is to consider a function of a single floating-point argument, $f$, \ie\ a function which maps $\mathbf{R}^1$ into itself. This procedure can be straightforwardly extended to $\mathbf{R}^d$ for functions of $d$ arguments. If the function is analytic within $C_{x_n}$, then this open set will be mapped into some other open set of $\mathbf{R}^1$, denoted $D^{f(x_n)}$. By construction, the intersection of $D^{f(x_n)}$ with the charts, $C$, is non-empty. Indeed, $D^{f(x_n)}$ intersects at least one chart, and in the case there are several they must have consecutive labels. In this manner, we can instead think of the function as mapping one label, $x_n$, into a set of labels $\{x_{m}\}$, where the set is non-empty, and the elements are consecutive. This is illustrated in \fig{Function}.

\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{Functions.pdf_t}}
\caption{A function, analytic on the open set $C_{x_n}$, which maps it into the open set $D^{f(x_n)}$. The latter intersects with $C_{x_m}, \ldots, C_{x_{m+3}}$. In terms of sets of labels, the function can be considered to map the element $x_n$ into the set $\{x_m, \ldots, x_{m+3}\}$.}
\label{fig:Function}
\end{center}
\end{figure}

How does all of this abstract machinery relate to floating-point functions on real hardware? We define a \emph{conforming} floating-point implementation of the function, $f$, to be a projection from $\{x_{m}, \ldots\}$ to a single element of this set. This projection will depend on many things: the precise implementation of $f$, the optimization used, the compiler flags used (such as \code{-ffast-math}), the rounding mode and the hardware. However, the idea is that every element of the set $\{x_{m}\}$ should be considered equally valid. Some examples may clarify this.

First, consider taking a number which has an exact floating-point representation and multiplying it by two.
In this case, $\{x_{m}, \ldots\}$ comprises just a single entry and our prescription demands an exact calculation. Secondly, take the example of \code{sin(1e100)}. In this case, $\{x_{m}, \ldots\}$ comprises all charts labelled by every representable number within the range $-1 \leq y \leq 1$. Our prescription states that every one of these numbers is an equally valid output from a conforming implementation. This puts our earlier intuition on a firm footing.

\subsubsection{Singularities}

There are two types of singularities to consider: those arising from arguments that are/are not exactly representable as a floating-point number. An example of the former is $\ln 0$. An example of the latter is $\tan \pi/2$. Both can be incorporated into our framework in a similar way. Any number on the real line will appear in either one of the $C_{x_n}$ or in two: it appears in one if the number is exactly representable as a floating-point number and two, otherwise. Regardless, the next step is to introduce new open sets by copying those charts in which a singular point of the function, $f$, occurs and deleting said point. Each open set for which this is done spawns a pair of open sets in which the function is now analytic. Under the action of $f$, these open sets are now mapped into open sets. To complete the construction, the partial closure of these mapped sets is considered by reinstating the singular point. This is illustrated in \fig{Singularity}, which nicely illustrates how the procedure captures the fact that $\tan \pi/2$ can be either $\pm \infty$, depending on the direction from which the singularity is approached.
\begin{figure}[h]
\begin{center}
\resizebox{25em}{!}{\input{Singularity.pdf_t}}
\caption{Excising a singular point from two charts which include $\pi/2$. The curved lines show how the nascent open sets are mapped into $\mathbf{R}^1$ under the action of $\tan$. The new charts to the left of $\pi/2$ are mapped to large positive numbers. Reinstating $\pi/2$ would provide the upper closure of these sets by $+\infty$. Similar considerations apply to the charts to the right of $\pi/2$, though here the mapping is in the vicinity of $-\infty$.}
\label{fig:Singularity}
\end{center}
\end{figure}

The rest of the prescription described above now follows, almost exactly as before. The only difference is that the $D^{f_{x_n}}$ may now contain two disjoint, but individually consecutive, sequences.

\subsection{Implications}

What does all of this mean in practice, especially when it comes to extending the reach of \constexpr\ throughout \cmath? The goal is not to be overly prescriptive, but rather to find a way of coherently and rigorously providing a framework  within which much of existing C++ practice and proposed extensions can reside. As such, we do not demand that the results of mathematical functions are necessarily the same at translation time and runtime. Indeed, we know that this can't be guaranteed and indeed already happens in practice. This is due, amongst other things, to the ability to change the rounding mode and runtime. But what we have done is to put limits on how answers may diverge, at least for conforming implementations.

Furthermore, it is conceivable that different platforms may in some circumstance generate radically
different code. For example, it will be possible to do things like this:
\begin{verbatim}
template<double D>
struct do_stuff
{
  static void execute() {}
};

template<>
struct do_stuff<0.5>
{
  static void execute() { destroy_everything(); }
};

// Do I feel lucky?
do_stuff<std::sin(1e100)>::execute();
\end{verbatim}

However, we believe that the utility of rolling out \constexpr\ to touch more of \cmath\ outweighs the fact that it may be abused, bringing us back to the core principle cited in the introduction, from~\cite{DandE}.
As for whether certain results may come as a surprise to users, again this is true. But that
is true of floating-point, period. It is a difficult, subtle area of programming fraught with difficulty
due to its frequently counter-intuitive nature.

One way or another, all of this boils down to the question of whether it is really acceptable for mathematical functions to give different results in different contexts, given the same input. Again, our answer is yes and we emphasise again that this is already part of C++. The above framework hopefully makes it clear that floating-point numbers are inherently fuzzy and that it is, in many cases, useful to embrace this fuzziness. That being said, there are cases where people may want a mathematical function to produce the same result, given the same input, in all situations (except, presumably, when the rounding mode is changed). Our opinion is that this is best served by a separate proposal, which
perhaps introduces new types. It is worth pointing out that Java gives a good idea of what this
may look like.


\section{State of the Art and Impact on Implementers}

\subsection{Generalities}

With the exception of the special functions [sf.cmath], functions taking a pointer argument and those with an explicit dependence on the runtime rounding mode (see section~\ref{sec:rounding}), GCC currently renders almost everything in \cmath\ \constexpr. Though clang does not have \constexpr implementations, it does perform compile time evaluation of many mathematical functions (but not the special functions) during optimisation. The existence of compile time evaluation in GCC and clang demonstrates that implementation of this proposal is plausibly feasible.

Nevertheless, even for GCC's implementation of the relatively simple functions which~\cite{Rosten-constexpr} declares \constexpr, there are subtleties. In particular GCC is not entirely consistent with the way in which it presently deals with NaNs and/or infinities when they are passed as arguments to various mathematical functions. The solution advocated by~\cite{Rosten-constexpr} is that, wherever possible, the C++ Standard defers to Annex F of the C Standard. This precisely defines when floating-point exceptions should be raised, and how NaNs and infinities should be treated. Regarding the former, raising anything other than \FEINEXACT\ renders a call non-constant.

\subsection{Garbage in, Garbage out}

{\bf TO DO:} hardware which gives e.g.\ $\code{sin 1e100} = 1e100$

\subsection{Conformance}

{\bf TO DO:} how tenable is it to test conformance of an implementation?


\section{Design Decisions}

The parent paper~\cite{Rosten-constexpr} identifies two crucial issues that must be understood when rolling out \constexpr\ in \cmath: namely error flags and the rounding mode. It is, however, well worth emphasising that these issues must have been confronted when allowing \Operators\ to be used in \constexpr\ contexts. Therefore, it would be most disconcerting if this were to provide a barrier to rolling out \constexpr\ in \cmath; nevertheless, both error flags and rounding mode are worthy of a proper discussion, which interested readers may find in~\cite{Rosten-constexpr}. The next two subsections summarise the key points, after which we discuss the subtle issue of the interaction with the C runtime library. Finally, the key proposal of this paper is given.

\subsection{Global Flags}

There are various scenarios under which certain functions in \cmath\ may set \code{errno} and/or raise exception flags, \FEDIVBYZERO, \FEINVALID, \FEOVERFLOW, \FEUNDERFLOW\ and
\FEINEXACT. Drawing on the behaviour of \Operators\ for inspiration, the proposal of~\cite{Rosten-constexpr} is as follows:
\begin{quotation}
	Functions declared \constexpr, \emph{when used in a \constexpr
context}, should give a compiler error if division by zero, domain errors or
overflows occur. When not used in a \constexpr context, the various global
flags should be set as normal.
\end{quotation}
At first sight, the distinction between these two contexts implies that many functions in \cmath\ may not be declared \constexpr\ as a pure library implementation. This is by no means the end of the world; however, the advent of \code{std::is\_constant\_evaluated()}~\cite{ConstEval}
may mean that a pure library implementation is possible.

\subsection{Rounding Mode}
\label{sec:rounding}

To facilitate discussion, \cite{Rosten-constexpr} defines two types of rounding-mode dependence: weak and strong. To illustrate weak dependence, consider
\begin{equation}
	\mbox{\code{constexpr double x\{10.0/3.0\}}}.
\label{eq:10/3}
\end{equation}
As an artefact of the limited precision of floating-point arithmetic, the answer depends on the rounding mode. However, this does not stop us from making definitions such as~\eq{10/3}. Therefore, functions  within \cmath\ that exhibit such weak dependence are not ruled out from being declared \constexpr.

This should be contrasted with strong dependence, which may be effectively illustrated by considering \code{float nearbyint(float x)}. The whole point of this function is to round depending on the runtime rounding mode, which may in principle be changed throughout a program's execution. It was therefore decided in~\cite{Rosten-constexpr} to exclude functions with strong dependence from being declared \constexpr\ and this paper does not overturn that.

\subsection{Interaction with the C standard Library}

For a mathematical function which may be evaluated at translation time, it is desirable for there to be
consistency with the values computed at runtime. However, the fact that the rounding mode
may be changed at runtime indicates that this is not, in general, possible. Nevertheless, for
weak rounding mode dependence the behaviour of \Operators\ indicates that this is acceptable.

 However, for more complicated mathematical functions there is an additional subtlety due
to the interaction with the C standard library. In [library.c] it is noted that \cmath\ makes available the facilities of the C standard library. One interpretation of this is that the C++
implementation could use one of several different C standard libraries. If so, 
constraining translation time behaviour so that it is consistent with the runtime behaviour
could be difficult, quite apart from the issue of the runtime rounding mode.

This is sharpened by the following code snippet, kindly brought to our attention by Richard Smith:

\begin{Verbatim}
#include <cmath>
double f() { return std::sin(1e100); }
\end{Verbatim}
For such code, any value in the range [-1, 1] could be considered reasonable and so it would not be expected to be consistent across library implementations. If it were possible to mark this function \constexpr, then strong differences between translation time and runtime could emerge. 

However, this is effectively already happening. It turns out that on clang (targeting x64), the following code is emitted:
\begin{Verbatim}
.LCPI0_0:
	.quad	-4622843457162800295 
_Z1fv:
	movsd	.LCPI0_0(%rip), %xmm0
	retq
\end{Verbatim}
with equivalent code generated by GCC.

This demonstrates that both compilers are already generating the results at translation time and, therefore, independently of the C library. For this particular example, it appears that current practise does indeed achieve consistency between translation time and runtime, though effectively by ignoring the latter!

The story does not end here. For more complicated examples and/or removing optimization, it may be that a call to the C library is made, after all. This implies that the value of, say, \code{std::sin(1e100)} evaluated in one part of a code base may be very different from the (translation time) value evaluated elsewhere. Nevertheless, it seems reasonable in our opinion that both clang and GCC tacitly allow this. The example we are using, while instructive, is somewhat artificial: it exploits the fact that the floating-point approximation to periodic function ceases to make much sense for arguments beyond a certain magnitude.


A conservative option for this proposal would be to simply remove the trigonometric functions from the list to which we apply \constexpr. We prefer not to do this but do acknowledge it as a possibility. On the one hand, allowing \constexpr\ trigonometric functions is consistent with the existing behaviour of at least two major compilers (we have not checked beyond these). On the other, we think that preventing this on the basis of edge cases which amount to something of an abuse of floating-point would be the tail wagging the dog.

\subsection{Conditions for \constexpr}

The conclusion of~\cite{Rosten-constexpr} was that two conditions may be used to systematically choose which functions in \cmath\ should be declared \constexpr. We reproduce these here, striking out the original form of the first, since this paper proposes removing it as a restriction:

\begin{proposal*}
	A function in \cmath\ shall be declared \constexpr if and only if:
	\begin{enumerate}
		\item \st{When taken to act on the set of rational numbers, the function is closed (excluding division 
		by zero);}
		
		The function does not belong to [sf.cmath];
		
		\item The function is not strongly dependent on the rounding mode.
	\end{enumerate}
\end{proposal*}



\section{Impact On the Standard}

This proposal amounts to a (further) liberal sprinkling of \constexpr\ in \cmath, together with a smattering in \complex. It may be possible to do this as a pure library extension if use is made of~\cite{ConstEval} but even without this it is hoped for the burden on compiler vendors to be minimal.

\section{Future Directions}

Ultimately it would be desirable to extend \constexpr\ to some, if not all, of the special functions.


\begin{acknowledgments}
	We would like to thank Richard Smith for his usual perceptive comments.
\end{acknowledgments}


\begin{thebibliography}{1}
	\bibitem[P0533]{Rosten-constexpr} Edward J.~Rosten and Oliver J.~Rosten, \constexpr\ for \cmath\ and \cstdlib.

	\bibitem[P2337]{Timmons-Less} Nicholas G. Timmons, Less \constexpr\ for \cmath.
	
	\bibitem[D\&E]{DandE} Bjarne Stroustrup, The Design and Evolution of C++.

	\bibitem[P0415R0]{AP-complex} Antony Polukhin, Constexpr for std::complex.	
	
	\bibitem[P0595]{ConstEval} Richard Smith, Andrew Sutton and Daveed Vandevoorde, \code{std\!::\!is\_constant\_evaluated()}.
	
	\bibitem[N4791]{WorkingPaper} Richard Smith, ed., Working Draft, Standard for Programming Language C++.	
	
\end{thebibliography}

\newpage

%\begin{widetext}
\onecolumngrid

\section{Proposed Wording}

\setlength{\parindent}{0pt}


The following proposed changes refer to the Working Paper~\cite{WorkingPaper}. Highlighting in \highlight{green} indicates changes proposed in this paper, whilst \oldhighlight{blue} indicates changes proposed in the companion paper, \cite{Rosten-constexpr}.



\subsection{Modifications to ``Header \header{complex} synposis'' [complex.syn]}

// [complex.value.ops], {\it values }

\vspace{2ex}

\code{
  	template<class T> constexpr T real(const complex<T>\&);
	
  	template<class T> constexpr T imag(const complex<T>\&);

	\vspace{2ex}

	template<class T> \highlight{constexpr} T abs(const complex<T>\&);
 	
	template<class T> \highlight{constexpr} T arg(const complex<T>\&);
	
	template<class T> constexpr T norm(const complex<T>\&);
	
	\vspace{2ex}
	
	template<class T> constexpr conj(const complex<T>\&);
	
	template<class T> \highlight{constexpr} proj(const complex<T>\&);
	
	template<class T> \highlight{constexpr} polar(const T\&, const T\& = T());	

}

\vspace{2ex}

// [complex.transcendentals], {\it transcendentals}

\code{

\vspace{2ex}
  template<class T> \highlight{constexpr} complex<T> acos(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> asin(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> atan(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> acosh(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> asinh(const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> atanh(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> cos  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> cosh (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> exp  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> log  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> log10(const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> pow  (const complex<T>\&, const T\&);

  template<class T> \highlight{constexpr} complex<T> pow  (const complex<T>\&, const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> pow  (const T\&, const complex<T>\&);

\vspace{2ex}

  template<class T> \highlight{constexpr} complex<T> sin  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> sinh (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> sqrt (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> tan  (const complex<T>\&);

  template<class T> \highlight{constexpr} complex<T> tanh (const complex<T>\&);
}

\subsection{Modifications to  ``Header \header{cmath} synopsis'' [cmath.syn]}


\code{

namespace std\{

\vspace{2ex}
\ldots
\vspace{2ex}

%% acos %%

\highlight{constexpr} float acos(float x); \stdcomment{library.c}

\highlight{constexpr} double acos(double x);

\highlight{constexpr} long double acos(long double x); \stdcomment{library.c}

\highlight{constexpr} float acosf(float x);

\highlight{constexpr} long double acosl(long double x);

\vspace{2ex}

%% asin %%

\highlight{constexpr} float asin(float x); \stdcomment{library.c}

\highlight{constexpr} double asin(double x);

\highlight{constexpr} long double asin(long double x); \stdcomment{library.c}

\highlight{constexpr} float asinf(float x);

\highlight{constexpr} long double asinl(long double x);

\vspace{2ex}

%% atan %%

\highlight{constexpr} float atan(float x); \stdcomment{library.c}

\highlight{constexpr} double atan(double x);

\highlight{constexpr} long double atan(long double x); \stdcomment{library.c}

\highlight{constexpr} float atanf(float x);

\highlight{constexpr} long double atanl(long double x);

\vspace{2ex}

%% atan2 %%

\highlight{constexpr} float atan2(float y, float x); \stdcomment{library.c}

\highlight{constexpr} double atan2(double y, double x);

\highlight{constexpr} long double atan2(long double y, long double x); \stdcomment{library.c}

\highlight{constexpr} float atan2f(float y, float x);

\highlight{constexpr} long double atan2l(long double y, long double x);

\vspace{2ex}

%% cos %%

\highlight{constexpr} float cos(float x); \stdcomment{library.c}

\highlight{constexpr} double cos(double x);

\highlight{constexpr} long double cos(long double x); \stdcomment{library.c}

\highlight{constexpr} float cosf(float x);

\highlight{constexpr} long double cosl(long double x);

\vspace{2ex}

%% sin %%

\highlight{constexpr} float sin(float x); \stdcomment{library.c}

\highlight{constexpr} double sin(double x);

\highlight{constexpr} long double sin(long double x); \stdcomment{library.c}

\highlight{constexpr} float sinf(float x);

\highlight{constexpr} long double sinl(long double x);

\vspace{2ex}

%% tan %%

\highlight{constexpr} float tan(float x); \stdcomment{library.c}

\highlight{constexpr} double tan(double x);

\highlight{constexpr} long double tan(long double x); \stdcomment{library.c}

\highlight{constexpr} float tanf(float x);

\highlight{constexpr} long double tanl(long double x);

\vspace{2ex}

%% acosh %%

\highlight{constexpr} float acosh(float x); \stdcomment{library.c}

\highlight{constexpr} double acosh(double x);

\highlight{constexpr} long double acosh(long double x); \stdcomment{library.c}

\highlight{constexpr} float acoshf(float x);

\highlight{constexpr} long double acoshl(long double x);

\vspace{2ex}

%% asinh %%

\highlight{constexpr} float asinh(float x); \stdcomment{library.c}

\highlight{constexpr} double asinh(double x);

\highlight{constexpr} long double asinh(long double x); \stdcomment{library.c}

\highlight{constexpr} float asinhf(float x);

\highlight{constexpr} long double asinhl(long double x);

\vspace{2ex}

%% atanh %%

\highlight{constexpr} float atanh(float x); \stdcomment{library.c}

\highlight{constexpr} double atanh(double x);

\highlight{constexpr} long double atanh(long double x); \stdcomment{library.c}

\highlight{constexpr} float atanhf(float x);

\highlight{constexpr} long double atanhl(long double x);

\vspace{2ex}

%% cosh %%

\highlight{constexpr} float cosh(float x); \stdcomment{library.c}

\highlight{constexpr} double cosh(double x);

\highlight{constexpr} long double cosh(long double x); \stdcomment{library.c}

\highlight{constexpr} float coshf(float x);

\highlight{constexpr} long double coshl(long double x);

\vspace{2ex}

%% sinh %%

\highlight{constexpr} float sinh(float x); \stdcomment{library.c}

\highlight{constexpr} double sinh(double x);

\highlight{constexpr} long double sinh(long double x); \stdcomment{library.c}

\highlight{constexpr} float sinhf(float x);

\highlight{constexpr} long double sinhl(long double x);

\vspace{2ex}

%% tanh %%

\highlight{constexpr} float tanh(float x); \stdcomment{library.c}

\highlight{constexpr} double tanh(double x);

\highlight{constexpr} long double tanh(long double x); \stdcomment{library.c}

\highlight{constexpr} float tanhf(float x);

\highlight{constexpr} long double tanhl(long double x);

\vspace{2ex}

%% exp %%

\highlight{constexpr} float exp(float x); \stdcomment{library.c}

\highlight{constexpr} double exp(double x);

\highlight{constexpr} long double exp(long double x); \stdcomment{library.c}

\highlight{constexpr} float expf(float x);

\highlight{constexpr} long double expl(long double x);

\vspace{2ex}

%% exp2 %%

\highlight{constexpr} float exp2(float x); \stdcomment{library.c}

\highlight{constexpr} double exp2(double x);

\highlight{constexpr} long double exp2(long double x); \stdcomment{library.c}

\highlight{constexpr} float exp2f(float x);

\highlight{constexpr} long double exp2l(long double x);

\vspace{2ex}

%% expm1 %%

\highlight{constexpr} float expm1(float x); \stdcomment{library.c}

\highlight{constexpr} double expm1(double x);

\highlight{constexpr} long double expm1(long double x); \stdcomment{library.c}

\highlight{constexpr} float expm1f(float x);

\highlight{constexpr} long double expm1l(long double x);

\vspace{2ex}

%% frexp %%

\oldhighlight{constexpr}  float frexp(float value, int* exp); \stdcomment{library.c}

\oldhighlight{constexpr}  double frexp(double value, int* exp);

\oldhighlight{constexpr}  long double frexp(long double value, int* exp); \stdcomment{library.c}

\oldhighlight{constexpr}  float frexpf(float value, int* exp);

\oldhighlight{constexpr}  long double frexpl(long double value, int* exp);

\vspace{2ex}

%% ilogb %%

\oldhighlight{constexpr} int ilogb(float x); \stdcomment{library.c}

\oldhighlight{constexpr} int ilogb(double x);

\oldhighlight{constexpr} int ilogb(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} int ilogbf(float x);

\oldhighlight{constexpr} int ilogbl(long double x);

\vspace{2ex}

%% ldexp %%

\oldhighlight{constexpr} float ldexp(float x, int exp); \stdcomment{library.c}

\oldhighlight{constexpr} double ldexp(double x, int exp);

\oldhighlight{constexpr} long double ldexp(long double x, int exp); \stdcomment{library.c}

\oldhighlight{constexpr} float ldexpf(float x, int exp);

\oldhighlight{constexpr} long double ldexpl(long double x, int exp);

\vspace{2ex}

%% log %%

\highlight{constexpr} float log(float x); \stdcomment{library.c}

\highlight{constexpr} double log(double x);

\highlight{constexpr} long double log(long double x); \stdcomment{library.c}

\highlight{constexpr} float logf(float x);

\highlight{constexpr} long double logl(long double x);

\vspace{2ex}

%% log 10 %%

\highlight{constexpr} float log10(float x); \stdcomment{library.c}

\highlight{constexpr} double log10(double x);

\highlight{constexpr} long double log10(long double x); \stdcomment{library.c}

\highlight{constexpr} float log10f(float x);

\highlight{constexpr} long double log10l(long double x);

\vspace{2ex}

%% loglp %%

\highlight{constexpr} float log1p(float x); \stdcomment{library.c}

\highlight{constexpr} double log1p(double x);

\highlight{constexpr}long double log1p(long double x); \stdcomment{library.c}

\highlight{constexpr} float log1pf(float x);

\highlight{constexpr} long double log1pl(long double x);

\vspace{2ex}

%% log2 %%

\highlight{constexpr} float log2(float x); \stdcomment{library.c}

\highlight{constexpr} double log2(double x);

\highlight{constexpr} long double log2(long double x); \stdcomment{library.c}

\highlight{constexpr} float log2f(float x);

\highlight{constexpr} long double log2l(long double x);

\vspace{2ex}

%% logb %%

\oldhighlight{constexpr} float logb(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double logb(double x);

\oldhighlight{constexpr} long double logb(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float logbf(float x);

\oldhighlight{constexpr} long double logbl(long double x);

\vspace{2ex}

%% modf %%

\oldhighlight{constexpr}  float modf(float value, float* iptr); \stdcomment{library.c}

\oldhighlight{constexpr}  double modf(double value, double* iptr);

\oldhighlight{constexpr}  long double modf(long double value, long double* iptr); \stdcomment{library.c}

\oldhighlight{constexpr}  float modff(float value, float* iptr);

\oldhighlight{constexpr}  long double modfl(long double value, long double* iptr);

\vspace{2ex}

%% scalbn %%

\oldhighlight{constexpr} float scalbn(float x, int n); \stdcomment{library.c}

\oldhighlight{constexpr} double scalbn(double x, int n);

\oldhighlight{constexpr} long double scalbn(long double x, int n); \stdcomment{library.c}

\oldhighlight{constexpr} float scalbnf(float x, int n);

\oldhighlight{constexpr} long double scalbnl(long double x, int n);

\vspace{2ex}

%% scalbln %%

\oldhighlight{constexpr} float scalbln(float x, long int n); \stdcomment{library.c}

\oldhighlight{constexpr} double scalbln(double x, long int n);

\oldhighlight{constexpr} long double scalbln(long double x, long int n); \stdcomment{library.c}

\oldhighlight{constexpr} float scalblnf(float x, long int n);

\oldhighlight{constexpr} long double scalblnl(long double x, long int n);

\vspace{2ex}

\highlight{constexpr} float cbrt(float x); \stdcomment{library.c}

\highlight{constexpr} double cbrt(double x);

\highlight{constexpr} long double cbrt(long double x); \stdcomment{library.c}

\highlight{constexpr} float cbrtf(float x);

\highlight{constexpr} long double cbrtl(long double x);

\vspace{2ex}

//  [c.math.abs], {\it absolute values}

%% abs %%

\oldhighlight{constexpr} int abs(int j);

\oldhighlight{constexpr} long int abs(long int j);

\oldhighlight{constexpr} long long int abs(long long int j);

\oldhighlight{constexpr} float abs(float j);

\oldhighlight{constexpr} double abs(double j);

\oldhighlight{constexpr}long double abs(long double j);

\vspace{2ex}

%% fabs %%

\oldhighlight{constexpr} float fabs(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double fabs(double x);

\oldhighlight{constexpr} long double fabs(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float fabsf(float x);

\oldhighlight{constexpr} long double fabsl(long double x);

\vspace{2ex}

%% hypot %%

\highlight{constexpr} float hypot(float x, float y); \stdcomment{library.c}

\highlight{constexpr} double hypot(double x, double y);

\highlight{constexpr} long double hypot(long double x, long double y); \stdcomment{library.c}

\highlight{constexpr} float hypotf(float x, float y);

\highlight{constexpr} long double hypotl(long double x, long double y);

\vspace{2ex}

// [c.math.hypot3], {\it three-dimensional hypotenuse}

%% hypot3 5%

\highlight{constexpr} float hypot(float x, float y, float z);

\highlight{constexpr} double hypot(double x, double y, double z);

\highlight{constexpr} long double hypot(long double x, long double y, long double z);

%% pow %%
\vspace{2ex}

\highlight{constexpr} float pow(float x, float y); \stdcomment{library.c}

\highlight{constexpr} double pow(double x, double y);

\highlight{constexpr} long double pow(double x, double y); \stdcomment{library.c}

\highlight{constexpr} float powf(float x, float y);

\highlight{constexpr} long double powl(long double x, long double y);

\vspace{2ex}

%% sqrt %%

\highlight{constexpr} float sqrt(float x); \stdcomment{library.c}

\highlight{constexpr} double sqrt(double x);

\highlight{constexpr} long double sqrt(double x); \stdcomment{library.c}

\highlight{constexpr} float sqrtf(float x);

\highlight{constexpr} long double sqrtl(long double x);

\vspace{2ex}

%% erf %%

\highlight{constexpr} float erf(float x); \stdcomment{library.c}

\highlight{constexpr} double erf(double x);

\highlight{constexpr} long double erf(long double x); \stdcomment{library.c}

\highlight{constexpr} float erff(float x);

\highlight{constexpr} long double erfl(long double x);

\vspace{2ex}
%% erfc %%

\highlight{constexpr} float erfc(float x); \stdcomment{library.c}

\highlight{constexpr} double erfc(double x);

\highlight{constexpr} long double erfc(long double x); \stdcomment{library.c}

\highlight{constexpr} float erfcf(float x);

\highlight{constexpr} long double erfcl(long double x);

\vspace{2ex}

%% lgamma %%

\highlight{constexpr} float lgamma(float x); \stdcomment{library.c}

\highlight{constexpr} double lgamma(double x);

\highlight{constexpr} long double lgamma(long double x); \stdcomment{library.c}

\highlight{constexpr} float lgammaf(float x);

\highlight{constexpr} long double lgammal(long double x);

\vspace{2ex}
%% tgamma %%

\highlight{constexpr} float tgamma(float x); \stdcomment{library.c}

\highlight{constexpr} double tgamma(double x);

\highlight{constexpr} long double tgamma(long double x); \stdcomment{library.c}

\highlight{constexpr} float tgammaf(float x);

\highlight{constexpr} long double tgammal(long double x);

\vspace{2ex}
%% ceil %%

\oldhighlight{constexpr} float ceil(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double ceil(double x);

\oldhighlight{constexpr} long double ceil(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float ceilf(float x);

\oldhighlight{constexpr} long double ceill(long double x);

\vspace{2ex}

%% floor %%

\oldhighlight{constexpr} float floor(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double floor(double x);

\oldhighlight{constexpr} long double floor(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float floorf(float x);

\oldhighlight{constexpr} long double floorl(long double x);

\vspace{2ex}

%% nearbyint %%

float nearbyint(float x); \stdcomment{library.c}

double nearbyint(double x);

long double nearbyint(long double x); \stdcomment{library.c}

 float nearbyintf(float x);

 long double nearbyintl(long double x);

\vspace{2ex}

%% rint %%

 float rint(float x); \stdcomment{library.c}

 double rint(double x);

long double rint(long double x); \stdcomment{library.c}

 float rintf(float x);

 long double rintl(long double x);

\vspace{2ex}

%% lrint %%

long int lrint(float x); \stdcomment{library.c}

 long int lrint(double x);

long int lrint(long double x); \stdcomment{library.c}

 long int lrintf(float x);

long int lrintl(long double x);

\vspace{2ex}

%% llrint %%

long long int llrint(float x); \stdcomment{library.c}

long long int llrint(double x);

long long int llrint(long double x); \stdcomment{library.c}

long long int llrintf(float x);

long long int llrintl(long double x);

\vspace{2ex}

%% round %%

\oldhighlight{constexpr} float round(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double round(double x);

\oldhighlight{constexpr} long double round(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float roundf(float x);

\oldhighlight{constexpr} long double roundl(long double x);

\vspace{2ex}

%% lround %%

\oldhighlight{constexpr} long int lround(float x); \stdcomment{library.c}

\oldhighlight{constexpr} long int lround(double x);

\oldhighlight{constexpr} long int lround(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} long int lroundf(float x);

\oldhighlight{constexpr} long int lroundl(long double x);

\vspace{2ex}

%% llround %%

\oldhighlight{constexpr} long long int llround(float x); \stdcomment{library.c}

\oldhighlight{constexpr} long long int llround(double x);

\oldhighlight{constexpr} long long int llround(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} long long int llroundf(float x);

\oldhighlight{constexpr} long long int llroundl(long double x);

\vspace{2ex}

%% trunc %%

\oldhighlight{constexpr} float trunc(float x); \stdcomment{library.c}

\oldhighlight{constexpr} double trunc(double x);

\oldhighlight{constexpr} long double trunc(long double x); \stdcomment{library.c}

\oldhighlight{constexpr} float truncf(float x);

\oldhighlight{constexpr} long double truncl(long double x);

\vspace{2ex}

%% fmod %%

\oldhighlight{constexpr} float fmod(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double fmod(double x, double y);

\oldhighlight{constexpr} long double fmod(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float fmodf(float x, float y);

\oldhighlight{constexpr} long double fmodl(long double x, long double y);

\vspace{2ex}

%% remainder %%

\oldhighlight{constexpr} float remainder(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double remainder(double x, double y);

\oldhighlight{constexpr} long double remainder(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float remainderf(float x, float y);

\oldhighlight{constexpr} long double remainderl(long double x, long double y);

\vspace{2ex}

%% remquo %%

\oldhighlight{constexpr}  float remquo(float x, float y, int* quo); \stdcomment{library.c}

\oldhighlight{constexpr}  double remquo(double x, double y, int* quo);

\oldhighlight{constexpr}  long double remquo(long double x, long double y, int* quo); \stdcomment{library.c}

\oldhighlight{constexpr}  float remquof(float x, float y, int* quo);

\oldhighlight{constexpr}  long double remquol(long double x, long double y, int* quo);

\vspace{2ex}

%% copysign %%

\oldhighlight{constexpr} float copysign(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr} double copysign(double x, double y);

\oldhighlight{constexpr} long double copysign(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr} float copysignf(float x, float y);

\oldhighlight{constexpr} long double copysignl(long double x, long double y);

\vspace{2ex}

double nan(const char* tagp);

float nanf(const char* tagp);

long double nanl(const char* tagp);

\vspace{2ex}

%% nextafter %%

\oldhighlight{constexpr}  float nextafter(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double nextafter(double x, double y);

\oldhighlight{constexpr}  long double nextafter(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float nextafterf(float x, float y);

\oldhighlight{constexpr}  long double nextafterl(long double x, long double y);

\vspace{2ex}

%% nexttoward %%

\oldhighlight{constexpr}  float nexttoward(float x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  double nexttoward(double x, long double y);

\oldhighlight{constexpr}  long double nexttoward(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float nexttowardf(float x, long double y);

\oldhighlight{constexpr}  long double nexttowardl(long double x, long double y);

\vspace{2ex}

%% fdim %%

\oldhighlight{constexpr}  float fdim(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fdim(double x, double y);

\oldhighlight{constexpr}  long double fdim(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fdimf(float x, float y);

\oldhighlight{constexpr}  long double fdiml(long double x, long double y);

\vspace{2ex}

%% fmax %%

\oldhighlight{constexpr}  float fmax(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fmax(double x, double y);

\oldhighlight{constexpr}  long double fmax(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fmaxf(float x, float y);

\oldhighlight{constexpr}  long double fmaxl(long double x, long double y);

\vspace{2ex}

%% fmin %%

\oldhighlight{constexpr} float fmin(float x, float y); \stdcomment{library.c}

\oldhighlight{constexpr}  double fmin(double x, double y);

\oldhighlight{constexpr}  long double fmin(long double x, long double y); \stdcomment{library.c}

\oldhighlight{constexpr}  float fminf(float x, float y);

\oldhighlight{constexpr} long double fminl(long double x, long double y);

\vspace{2ex}

%% fma %%

\oldhighlight{constexpr}  float fma(float x, float y, float z); \stdcomment{library.c}

\oldhighlight{constexpr}  double fma(double x, double y, double z);

\oldhighlight{constexpr}  long double fma(long double x, long double y, long double z); \stdcomment{library.c}

\oldhighlight{constexpr}  float fmaf(float x, float y, float z);

\oldhighlight{constexpr}  long double fmal(long double x, long double y, long double z);

\vspace{2ex}

// [c.math.fpclass], {\it classification / comparison functions:}

%% fpclassify %%

\oldhighlight{constexpr} int fpclassify(float x);

\oldhighlight{constexpr} int fpclassify(double x);

\oldhighlight{constexpr} int fpclassify(long double x);

\vspace{2ex}

%% isinfinite %%

\oldhighlight{constexpr} int isfinite(float x);

\oldhighlight{constexpr} int isfinite(double x);

\oldhighlight{constexpr} int isfinite(long double x);

\vspace{2ex}

%% isinf %%

\oldhighlight{constexpr} int isinf(float x);

\oldhighlight{constexpr} int isinf(double x);

\oldhighlight{constexpr} int isinf(long double x);

\vspace{2ex}

%% isnan %%

\oldhighlight{constexpr} int isnan(float x);

\oldhighlight{constexpr} int isnan(double x);

\oldhighlight{constexpr} int isnan(long double x);

\vspace{2ex}

%% isnormal %%

\oldhighlight{constexpr} int isnormal(float x);

\oldhighlight{constexpr} int isnormal(double x);

\oldhighlight{constexpr} int isnormal(long double x);

\vspace{2ex}

%% signbit %%

\oldhighlight{constexpr} int signbit(float x);

\oldhighlight{constexpr} int signbit(double x);

\oldhighlight{constexpr} int signbit(long double x);

\vspace{2ex}

%% isgreater %%

\oldhighlight{constexpr} int isgreater(float x, float y);

\oldhighlight{constexpr} int isgreater(double x, double y);

\oldhighlight{constexpr} int isgreater(long double x, long double y);

\vspace{2ex}

%% isgreaterequal %%

\oldhighlight{constexpr} int isgreaterequal(float x, float y);

\oldhighlight{constexpr} int isgreaterequal(double x, double y);

\oldhighlight{constexpr} int isgreaterequal(long double x, long double y);

\vspace{2ex}

%% isless %%

\oldhighlight{constexpr} int isless(float x, float y);

\oldhighlight{constexpr} int isless(double x, double y);

\oldhighlight{constexpr} int isless(long double x, long double y);

\vspace{2ex}

%% islessequal %%

\oldhighlight{constexpr} int islessequal(float x, float y);

\oldhighlight{constexpr} int islessequal(double x, double y);

\oldhighlight{constexpr} int islessequal(long double x, long double y);

\vspace{2ex}

%% islessgreater %%

\oldhighlight{constexpr} int islessgreater(float x, float y);

\oldhighlight{constexpr} int islessgreater(double x, double y);

\oldhighlight{constexpr} int islessgreater(long double x, long double y);

\vspace{2ex}

%% isunordered %%

\oldhighlight{constexpr} int isunordered(float x, float y);

\oldhighlight{constexpr} int isunordered(double x, double y);

\oldhighlight{constexpr} int isunordered(long double x, long double y);

}


\subsection{Modifications to ``Three-dimensional hypotenuse''  [c.math.hpot3]}

\code{
	\highlight{constexpr} float hypot(float x, float y); 

	\highlight{constexpr} double hypot(double x, double y);

	\highlight{constexpr} long double hypot(double x, double y); 
}

\end{document}
